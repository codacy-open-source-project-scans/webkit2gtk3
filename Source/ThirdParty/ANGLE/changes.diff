diff --git a/src/common/utilities.cpp b/src/common/utilities.cpp
index 34826b47554d0d89e8b9619d46828177b2c1b873..2e03a110de26a7cb888d8e9a5997deaf3745c12c 100644
--- a/src/common/utilities.cpp
+++ b/src/common/utilities.cpp
@@ -6,6 +6,12 @@
 
 // utilities.cpp: Conversion functions and other utility routines.
 
+// Older clang versions have a false positive on this warning here.
+// TODO(dino): Is this still necessary?
+#if defined(__clang__)
+#    pragma clang diagnostic ignored "-Wglobal-constructors"
+#endif
+
 #include "common/utilities.h"
 #include "GLES3/gl3.h"
 #include "common/mathutil.h"
diff --git a/src/compiler/preprocessor/preprocessor_tab_autogen.cpp b/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
index a7607c9e529ce7a57bdc6c3c82134b144eb67130..c9ec1adec020589bd4fcfe226721042a8f2c6cf5 100644
--- a/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
+++ b/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.8.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
diff --git a/src/compiler/translator/ValidateTypeSizeLimitations.cpp b/src/compiler/translator/ValidateTypeSizeLimitations.cpp
index 2a033ad9d9422349865a9f2af7084bbf1c2c23d9..a6bf9d0db544e93b2f9135221c4a409eafc324e5 100644
--- a/src/compiler/translator/ValidateTypeSizeLimitations.cpp
+++ b/src/compiler/translator/ValidateTypeSizeLimitations.cpp
@@ -7,6 +7,7 @@
 #include "compiler/translator/ValidateTypeSizeLimitations.h"
 
 #include "angle_gl.h"
+#include "common/mathutil.h"
 #include "compiler/translator/Diagnostics.h"
 #include "compiler/translator/Symbol.h"
 #include "compiler/translator/SymbolTable.h"
@@ -113,7 +114,8 @@ class ValidateTypeSizeLimitationsTraverser : public TIntermTraverser
 
     void validateTotalPrivateVariableSize()
     {
-        if (mTotalPrivateVariablesSize > kMaxPrivateVariableSizeInBytes)
+        if (mTotalPrivateVariablesSize.ValueOrDefault(std::numeric_limits<size_t>::max()) >
+            kMaxPrivateVariableSizeInBytes)
         {
             mDiagnostics->error(
                 TSourceLoc{},
@@ -231,7 +233,7 @@ class ValidateTypeSizeLimitationsTraverser : public TIntermTraverser
     TDiagnostics *mDiagnostics;
     std::vector<int> mLoopSymbolIds;
 
-    size_t mTotalPrivateVariablesSize;
+    angle::base::CheckedNumeric<size_t> mTotalPrivateVariablesSize;
 };
 
 }  // namespace
diff --git a/src/compiler/translator/glslang_tab_autogen.cpp b/src/compiler/translator/glslang_tab_autogen.cpp
index 233b571b7985ba9d33b245f495725851a12be569..6bd263e0b1ec4137e5b8bb1a6269ce07cc8a6b32 100644
--- a/src/compiler/translator/glslang_tab_autogen.cpp
+++ b/src/compiler/translator/glslang_tab_autogen.cpp
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.8.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
diff --git a/src/compiler/translator/glslang_tab_autogen.h b/src/compiler/translator/glslang_tab_autogen.h
index d5a48edd40f382359db76acf1a1ce75b6a6dc6d5..907c62e0bb659292b3912707904981863429478a 100644
--- a/src/compiler/translator/glslang_tab_autogen.h
+++ b/src/compiler/translator/glslang_tab_autogen.h
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.8.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison interface for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
diff --git a/src/libANGLE/State.cpp b/src/libANGLE/State.cpp
index 12e40f45e02b091c76f4b22c555be19935f3efda..371c9854abc9fffb3d4422fc27545dfad74cc035 100644
--- a/src/libANGLE/State.cpp
+++ b/src/libANGLE/State.cpp
@@ -6,6 +6,9 @@
 
 // State.cpp: Implements the State class, encapsulating raw GL state.
 
+// Older clang versions have a false positive on this warning here.
+#pragma clang diagnostic ignored "-Wglobal-constructors"
+
 #include "libANGLE/State.h"
 
 #include <string.h>
diff --git a/src/libANGLE/features.h b/src/libANGLE/features.h
index a65ef28b470ade5b8447b98ae788caeb18e8b98a..f081511ccf62dd88d4252a8b2a596a4510930797 100644
--- a/src/libANGLE/features.h
+++ b/src/libANGLE/features.h
@@ -47,4 +47,11 @@
 #    define ANGLE_PROGRAM_LINK_VALIDATE_UNIFORM_PRECISION ANGLE_ENABLED
 #endif
 
+// Lose context on Metal command queue error
+// ENABLED check Metal command buffer status on completion for error and lose context on error.
+// DISABLED Metal backed contexts are never lost.
+#if !defined(ANGLE_METAL_LOSE_CONTEXT_ON_ERROR)
+#    define ANGLE_METAL_LOSE_CONTEXT_ON_ERROR ANGLE_ENABLED
+#endif
+
 #endif  // LIBANGLE_FEATURES_H_
diff --git a/src/libANGLE/formatutils.cpp b/src/libANGLE/formatutils.cpp
index f2845dc9f9a81fe072fc4ae790c6bb3dfac5b5d8..e2b5cd91e8ce813c10d42aaf6540422b6cdc984b 100644
--- a/src/libANGLE/formatutils.cpp
+++ b/src/libANGLE/formatutils.cpp
@@ -609,6 +609,13 @@ static GLenum EquivalentBlitInternalFormat(GLenum internalformat)
         return GL_RGB8;
     }
 
+    // Treat ANGLE's BGRA8_SRGB as SRGB8_ALPHA8 since it's just a swizzled version
+    // with the same components.
+    if (internalformat == GL_BGRA8_SRGB_ANGLEX)
+    {
+        return GL_SRGB8_ALPHA8_EXT;
+    }
+
     return internalformat;
 }
 
diff --git a/src/libANGLE/renderer/metal/BufferMtl.mm b/src/libANGLE/renderer/metal/BufferMtl.mm
index 746823ce009702c2e49d1397a4159570838ebc9e..7976bcadedd832cabfda3f37b69ca4577e50bdf4 100644
--- a/src/libANGLE/renderer/metal/BufferMtl.mm
+++ b/src/libANGLE/renderer/metal/BufferMtl.mm
@@ -390,7 +390,7 @@ ConversionBufferMtl *BufferMtl::getUniformConversionBuffer(ContextMtl *context,
         {
             if (buffer.offset.second <= offset.second &&
                 (offset.second - buffer.offset.second) % buffer.uniformBufferBlockSize == 0)
-                return &buffer;
+                return static_cast<ConversionBufferMtl *>(&buffer);
         }
     }
 
diff --git a/src/libANGLE/renderer/metal/ContextMtl.mm b/src/libANGLE/renderer/metal/ContextMtl.mm
index 97d935b275c0a0aaac841e5a413d38b9080b9ec0..a99cc00861212c3d61e8328cabd03c6f63e1cd00 100644
--- a/src/libANGLE/renderer/metal/ContextMtl.mm
+++ b/src/libANGLE/renderer/metal/ContextMtl.mm
@@ -1070,6 +1070,13 @@ angle::Result ContextMtl::multiDrawElementsInstancedBaseVertexBaseInstance(
 // Device loss
 gl::GraphicsResetStatus ContextMtl::getResetStatus()
 {
+#if ANGLE_METAL_LOSE_CONTEXT_ON_ERROR == ANGLE_ENABLED
+    if (cmdQueue().isDeviceLost())
+    {
+        return gl::GraphicsResetStatus::UnknownContextReset;
+    }
+#endif
+
     return gl::GraphicsResetStatus::NoError;
 }
 
@@ -2464,8 +2471,22 @@ angle::Result ContextMtl::setupDraw(const gl::Context *context,
             return angle::Result::Continue;
         }
         // Setup with flushed state should either produce a working encoder or fail with an error
-        // result.
-        ASSERT(mRenderEncoder.valid());
+        // result. if that's not the case, something's gone seriously wrong. Try to
+        // recover from the error by bailing out of the draw call, and finishing the command buffer.
+        // This will result in an unfinished / corrupted draw, but will avoid a browser/GPU process
+        // crash.
+        if (ANGLE_UNLIKELY(!mRenderEncoder.valid() || !mRenderEncoder.hasPipelineState()))
+        {
+            // Completely flush the command buffer, waiting synchronously.
+            flushCommandBuffer(mtl::WaitUntilFinished);
+            // Invalidate all state
+            invalidateState(context);
+            // Return fail, and drop the draw call. This is
+            // a worst case scenario. If in a debug roots situation,
+            // we should try to catch the call stack.
+            ERR() << "Draw call is unusable - please report a bug on bugs.webkit.org";
+            return angle::Result::Stop;
+        }
     }
     return angle::Result::Continue;
 }
diff --git a/src/libANGLE/renderer/metal/DisplayMtl.mm b/src/libANGLE/renderer/metal/DisplayMtl.mm
index d29e97237fad421a73f0d9a573e5618751a28b3c..95bd42f351d5a6adda2547f419cd0d31d00ca2b9 100644
--- a/src/libANGLE/renderer/metal/DisplayMtl.mm
+++ b/src/libANGLE/renderer/metal/DisplayMtl.mm
@@ -28,7 +28,9 @@
 #include "mtl_command_buffer.h"
 #include "platform/PlatformMethods.h"
 
-#if TARGET_OS_SIMULATOR
+#if ANGLE_METAL_XCODE_BUILDS_SHADERS
+#   include "libANGLE/renderer/metal/mtl_default_shaders_compiled.inc"
+#elif TARGET_OS_SIMULATOR
 #    include "libANGLE/renderer/metal/shaders/mtl_internal_shaders_src_autogen.h"
 #elif defined(ANGLE_PLATFORM_MACOS)
 #    include "libANGLE/renderer/metal/shaders/mtl_internal_shaders_2_0_macos_autogen.h"
@@ -180,12 +182,22 @@ void DisplayMtl::terminate()
 
 bool DisplayMtl::testDeviceLost()
 {
+#if ANGLE_METAL_LOSE_CONTEXT_ON_ERROR == ANGLE_ENABLED
+    return mCmdQueue.isDeviceLost();
+#else
      return false;
+#endif
 }
 
 egl::Error DisplayMtl::restoreLostDevice(const egl::Display *display)
 {
+#if ANGLE_METAL_LOSE_CONTEXT_ON_ERROR == ANGLE_ENABLED
+    // A Metal device cannot be restored, the entire context would have to be
+    // re-created along with any other EGL objects that reference it.
+    return egl::EglBadDisplay();
+#else
     return egl::NoError();
+#endif
 }
 
 std::string DisplayMtl::getRendererDescription()
@@ -1348,6 +1360,14 @@ void DisplayMtl::initializeFeatures()
 angle::Result DisplayMtl::initializeShaderLibrary()
 {
     mtl::AutoObjCPtr<NSError *> err = nil;
+#ifdef ANGLE_METAL_XCODE_BUILDS_SHADERS
+    const uint8_t *compiled_shader_binary;
+    size_t compiled_shader_binary_len;
+    compiled_shader_binary                           = gMetalBinaryShaders;
+    compiled_shader_binary_len                       = gMetalBinaryShaders_len;
+    mDefaultShaders =
+        mtl::CreateShaderLibraryFromBinary(getMetalDevice(), compiled_shader_binary, compiled_shader_binary_len, &err);
+#else
 #if TARGET_OS_SIMULATOR
     mDefaultShaders = mtl::CreateShaderLibrary(getMetalDevice(), gDefaultMetallibSrc,
                                                std::size(gDefaultMetallibSrc), &err);
@@ -1368,7 +1388,7 @@ angle::Result DisplayMtl::initializeShaderLibrary()
     mDefaultShaders =
         mtl::CreateShaderLibraryFromBinary(getMetalDevice(), metalLibData, metalLibDataSize, &err);
 #endif
-
+#endif
     if (err)
     {
         ERR() << "Internal error: " << err.get().localizedDescription.UTF8String;
@@ -1401,8 +1421,7 @@ bool DisplayMtl::supportsEitherGPUFamily(uint8_t iOSFamily, uint8_t macFamily) c
 bool DisplayMtl::supports32BitFloatFiltering() const
 {
 #if (defined(__MAC_11_0) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_11_0) || \
-    (defined(__IPHONE_14_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_14_0) || \
-    (defined(__TVOS_14_0) && __TV_OS_VERSION_MIN_REQUIRED >= __TVOS_14_0)
+    (defined(__IPHONE_14_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_14_0)
     if (@available(ios 14.0, macOS 11.0, *))
     {
         return [mMetalDevice supports32BitFloatFiltering];
diff --git a/src/libANGLE/renderer/metal/FrameBufferMtl.mm b/src/libANGLE/renderer/metal/FrameBufferMtl.mm
index f7eaf3362c8fd382ea047a68372c9b6d9213a2f8..af009029c5d980b9e8e084554ba77c0821aa2482 100644
--- a/src/libANGLE/renderer/metal/FrameBufferMtl.mm
+++ b/src/libANGLE/renderer/metal/FrameBufferMtl.mm
@@ -1660,8 +1660,13 @@ angle::Result FramebufferMtl::readPixelsToPBO(const gl::Context *context,
 
     ContextMtl *contextMtl = mtl::GetImpl(context);
 
-    ANGLE_MTL_CHECK(contextMtl, packPixelsParams.offset <= std::numeric_limits<uint32_t>::max(),
+    if constexpr (sizeof(packPixelsParams.offset) > sizeof(uint32_t))
+    {
+        ANGLE_MTL_CHECK(contextMtl,
+                        static_cast<std::make_unsigned_t<decltype(packPixelsParams.offset)>>(
+                            packPixelsParams.offset) <= std::numeric_limits<uint32_t>::max(),
                         GL_INVALID_OPERATION);
+    }
     uint32_t offset = static_cast<uint32_t>(packPixelsParams.offset);
 
     BufferMtl *packBufferMtl = mtl::GetImpl(packPixelsParams.packBuffer);
diff --git a/src/libANGLE/renderer/metal/ProgramMtl.mm b/src/libANGLE/renderer/metal/ProgramMtl.mm
index 04fc45023497f3fdbf061b24197e40fae35f8c17..db63bd65d01aaddc48252fda8bd765988d7ddc20 100644
--- a/src/libANGLE/renderer/metal/ProgramMtl.mm
+++ b/src/libANGLE/renderer/metal/ProgramMtl.mm
@@ -54,8 +54,25 @@ class [[nodiscard]] ScopedAutoClearVector
     std::vector<T> &mArray;
 };
 
+inline void memcpy_guarded(void *dst, const void *src, const void *maxSrcPtr, size_t size)
+{
+    size_t bytesAvailable = maxSrcPtr > src ? (const uint8_t *)maxSrcPtr - (const uint8_t *)src : 0;
+    size_t bytesToCopy    = std::min(size, bytesAvailable);
+    size_t bytesToZero    = size - bytesToCopy;
+
+    if (bytesToCopy)
+        memcpy(dst, src, bytesToCopy);
+    if (bytesToZero)
+        memset((uint8_t *)dst + bytesToCopy, 0, bytesToZero);
+}
+
 // Copy matrix one column at a time
-inline void copy_matrix(void *dst, const void *src, size_t srcStride, size_t dstStride, GLenum type)
+inline void copy_matrix(void *dst,
+                        const void *src,
+                        const void *maxSrcPtr,
+                        size_t srcStride,
+                        size_t dstStride,
+                        GLenum type)
 {
     size_t elemSize      = mtl::GetMetalSizeForGLType(gl::VariableComponentType(type));
     const size_t dstRows = gl::VariableRowCount(type);
@@ -64,14 +81,15 @@ inline void copy_matrix(void *dst, const void *src, size_t srcStride, size_t dst
     for (size_t col = 0; col < dstCols; col++)
     {
         size_t srcOffset = col * srcStride;
-        memcpy(((uint8_t *)dst) + dstStride * col, (const uint8_t *)src + srcOffset,
-               elemSize * dstRows);
+        memcpy_guarded(((uint8_t *)dst) + dstStride * col, (const uint8_t *)src + srcOffset,
+                       maxSrcPtr, elemSize * dstRows);
     }
 }
 
 // Copy matrix one element at a time to transpose.
 inline void copy_matrix_row_major(void *dst,
                                   const void *src,
+                                  const void *maxSrcPtr,
                                   size_t srcStride,
                                   size_t dstStride,
                                   GLenum type)
@@ -85,8 +103,8 @@ inline void copy_matrix_row_major(void *dst,
         for (size_t row = 0; row < dstRows; row++)
         {
             size_t srcOffset = row * srcStride + col * elemSize;
-            memcpy((uint8_t *)dst + dstStride * col + row * elemSize,
-                   (const uint8_t *)src + srcOffset, elemSize);
+            memcpy_guarded((uint8_t *)dst + dstStride * col + row * elemSize,
+                           (const uint8_t *)src + srcOffset, maxSrcPtr, elemSize);
         }
     }
 }
@@ -105,6 +123,7 @@ angle::Result ConvertUniformBufferData(ContextMtl *contextMtl,
                                        size_t *bufferOffsetOut)
 {
     uint8_t *dst             = nullptr;
+    const uint8_t *maxSrcPtr = sourceData + sizeToCopy;
     dynamicBuffer->releaseInFlightBuffers(contextMtl);
 
     // When converting a UBO buffer, we convert all of the data
@@ -149,12 +168,12 @@ angle::Result ConvertUniformBufferData(ContextMtl *contextMtl,
                     // Transpose matricies into column major order, if they're row major encoded.
                     if (stdIterator->isRowMajorMatrix)
                     {
-                        copy_matrix_row_major(dstMat, srcMat, stdIterator->matrixStride,
+                        copy_matrix_row_major(dstMat, srcMat, maxSrcPtr, stdIterator->matrixStride,
                                               mtlIterator->matrixStride, mtlIterator->type);
                     }
                     else
                     {
-                        copy_matrix(dstMat, srcMat, stdIterator->matrixStride,
+                        copy_matrix(dstMat, srcMat, maxSrcPtr, stdIterator->matrixStride,
                                     mtlIterator->matrixStride, mtlIterator->type);
                     }
                 }
@@ -166,24 +185,25 @@ angle::Result ConvertUniformBufferData(ContextMtl *contextMtl,
                     for (int boolCol = 0; boolCol < gl::VariableComponentCount(mtlIterator->type);
                          boolCol++)
                     {
-                        const uint8_t *srcOffset =
+                        const uint8_t *srcBool =
                             (sourceData + stdIterator->offset + stdArrayOffset +
                              blockConversionInfo.stdSize() * i +
                              gl::VariableComponentSize(GL_BOOL) * boolCol);
-                        unsigned int srcValue = *((unsigned int *)(srcOffset));
-                        bool boolVal          = bool(srcValue);
-                        memcpy(dst + mtlIterator->offset + mtlArrayOffset +
-                                   blockConversionInfo.metalSize() * i + sizeof(bool) * boolCol,
-                               &boolVal, sizeof(bool));
+                        unsigned int srcValue =
+                            srcBool < maxSrcPtr ? *((unsigned int *)(srcBool)) : 0;
+                        uint8_t *dstBool = dst + mtlIterator->offset + mtlArrayOffset +
+                                           blockConversionInfo.metalSize() * i +
+                                           sizeof(bool) * boolCol;
+                        *dstBool = (srcValue != 0);
                     }
                 }
                 else
                 {
-                    memcpy(dst + mtlIterator->offset + mtlArrayOffset +
+                    memcpy_guarded(dst + mtlIterator->offset + mtlArrayOffset +
                                        blockConversionInfo.metalSize() * i,
                                    sourceData + stdIterator->offset + stdArrayOffset +
                                        blockConversionInfo.stdSize() * i,
-                           mtl::GetMetalSizeForGLType(mtlIterator->type));
+                                   maxSrcPtr, mtl::GetMetalSizeForGLType(mtlIterator->type));
                 }
             }
             ++stdIterator;
@@ -1555,7 +1575,7 @@ angle::Result ProgramMtl::setupDraw(const gl::Context *glContext,
                                     bool uniformBuffersDirty)
 {
     ContextMtl *context = mtl::GetImpl(glContext);
-    if (pipelineDescChanged)
+    if (pipelineDescChanged || !cmdEncoder->hasPipelineState())
     {
         id<MTLFunction> vertexShader = nil;
         ANGLE_TRY(
diff --git a/src/libANGLE/renderer/metal/VertexArrayMtl.mm b/src/libANGLE/renderer/metal/VertexArrayMtl.mm
index 1d30b25345df8e39a4b20056b6906fc548a288e3..5a27b90c5943679f2f9e9c5b7565c308cf273a1a 100644
--- a/src/libANGLE/renderer/metal/VertexArrayMtl.mm
+++ b/src/libANGLE/renderer/metal/VertexArrayMtl.mm
@@ -1111,16 +1111,23 @@ angle::Result VertexArrayMtl::convertVertexBufferGPU(const gl::Context *glContex
     ANGLE_TRY(conversion->data.allocate(contextMtl, numVertices * targetStride, nullptr, &newBuffer,
                                         &newBufferOffset));
 
-    ANGLE_CHECK_GL_MATH(contextMtl, binding.getOffset() <= std::numeric_limits<uint32_t>::max());
+    GLintptr bindingOffset = binding.getOffset();
+
+    if constexpr (sizeof(bindingOffset) > sizeof(uint32_t))
+        ANGLE_CHECK_GL_MATH(contextMtl, static_cast<std::make_unsigned_t<decltype(bindingOffset)>>(
+                                            bindingOffset) <= std::numeric_limits<uint32_t>::max());
     ANGLE_CHECK_GL_MATH(contextMtl, newBufferOffset <= std::numeric_limits<uint32_t>::max());
     ANGLE_CHECK_GL_MATH(contextMtl, numVertices <= std::numeric_limits<uint32_t>::max());
 
     mtl::VertexFormatConvertParams params;
     VertexConversionBufferMtl *vertexConversion =
         static_cast<VertexConversionBufferMtl *>(conversion);
+    if constexpr (sizeof(vertexConversion->offset) > sizeof(uint32_t))
+        ANGLE_CHECK_GL_MATH(contextMtl,
+                            vertexConversion->offset <= std::numeric_limits<uint32_t>::max());
     params.srcBuffer            = srcBuffer->getCurrentBuffer();
-    params.srcBufferStartOffset = static_cast<uint32_t>(
-        MIN(static_cast<GLintptr>(vertexConversion->offset), binding.getOffset()));
+    params.srcBufferStartOffset = std::min(static_cast<uint32_t>(vertexConversion->offset),
+                                           static_cast<uint32_t>(bindingOffset));
     params.srcStride            = binding.getStride();
     params.srcDefaultAlphaData  = convertedFormat.defaultAlpha;
 
diff --git a/src/libANGLE/renderer/metal/mtl_command_buffer.h b/src/libANGLE/renderer/metal/mtl_command_buffer.h
index 5f516c7c5bd4ee8844ca88905638135208cea8e6..454c8768b923fe156dd252e1a3dec66174461d01 100644
--- a/src/libANGLE/renderer/metal/mtl_command_buffer.h
+++ b/src/libANGLE/renderer/metal/mtl_command_buffer.h
@@ -88,6 +88,8 @@ class CommandQueue final : public WrappedObject<id<MTLCommandQueue>>, angle::Non
     bool isTimeElapsedEntryComplete(uint64_t id);
     double getTimeElapsedEntryInSeconds(uint64_t id);
 
+    bool isDeviceLost() const { return mIsDeviceLost; }
+
   private:
     void onCommandBufferCompleted(id<MTLCommandBuffer> buf,
                                   uint64_t serial,
@@ -129,6 +131,8 @@ class CommandQueue final : public WrappedObject<id<MTLCommandQueue>>, angle::Non
     void recordCommandBufferTimeElapsed(std::lock_guard<std::mutex> &lg,
                                         uint64_t id,
                                         double seconds);
+
+    std::atomic_bool mIsDeviceLost = false;
 };
 
 class CommandBuffer final : public WrappedObject<id<MTLCommandBuffer>>, angle::NonCopyable
@@ -539,6 +543,7 @@ class RenderCommandEncoder final : public CommandEncoder
 
     const RenderPassDesc &renderPassDesc() const { return mRenderPassDesc; }
     bool hasDrawCalls() const { return mHasDrawCalls; }
+    bool hasPipelineState() const { return mPipelineStateSet; }
 
     uint64_t getSerial() const { return mSerial; }
 
diff --git a/src/libANGLE/renderer/metal/mtl_command_buffer.mm b/src/libANGLE/renderer/metal/mtl_command_buffer.mm
index d6505275894b1d3ce1b94df7d28e7894eb5ece93..0484aa989495cdfea78e171c5ce680408aa2a9d1 100644
--- a/src/libANGLE/renderer/metal/mtl_command_buffer.mm
+++ b/src/libANGLE/renderer/metal/mtl_command_buffer.mm
@@ -372,6 +372,16 @@ inline void SetVisibilityResultModeCmd(id<MTLRenderCommandEncoder> encoder,
     [encoder setVisibilityResultMode:mode offset:offset];
 }
 
+#if (defined(__MAC_10_15) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_15) || \
+    (defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_13_0)
+#    define ANGLE_MTL_USE_RESOURCE_USAGE_STAGES_AVAILABLE 1
+#endif
+
+#if (defined(__MAC_13_0) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_13_0) || \
+    (defined(__IPHONE_16_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_16_0)
+#    define ANGLE_MTL_USE_RESOURCE_USAGE_DEPRECATED 1
+#endif
+
 inline void UseResourceCmd(id<MTLRenderCommandEncoder> encoder, IntermediateCommandStream *stream)
 {
     id<MTLResource> resource = stream->fetch<id<MTLResource>>();
@@ -595,6 +605,12 @@ void CommandQueue::onCommandBufferCompleted(id<MTLCommandBuffer> buf,
 
     ANGLE_MTL_LOG("Completed MTLCommandBuffer %llu:%p", serial, buf);
 
+    if ([buf status] != MTLCommandBufferStatusCompleted)
+    {
+        mIsDeviceLost = true;
+        return;
+    }
+
     if (timeElapsedEntry != 0)
     {
         // Record this command buffer's elapsed time.
diff --git a/src/libANGLE/renderer/metal/mtl_default_shaders_compiled.inc b/src/libANGLE/renderer/metal/mtl_default_shaders_compiled.inc
new file mode 100644
index 0000000000000000000000000000000000000000..64b587ddff57a8c26d5bd3739889951af66d92b6
--- /dev/null
+++ b/src/libANGLE/renderer/metal/mtl_default_shaders_compiled.inc
@@ -0,0 +1 @@
+// placeholder for WebKit
diff --git a/src/libANGLE/renderer/metal/mtl_render_utils.h b/src/libANGLE/renderer/metal/mtl_render_utils.h
index 774887d45e0d45b31e9878b5b397222201fece73..866f5e576841adc92496baac1fad7efcd4b5c2d8 100644
--- a/src/libANGLE/renderer/metal/mtl_render_utils.h
+++ b/src/libANGLE/renderer/metal/mtl_render_utils.h
@@ -219,7 +219,7 @@ class ClearUtils final : angle::NonCopyable
     const std::string mFragmentShaderName;
 
     // Render pipeline cache for clear with draw:
-    std::array<RenderPipelineCache, kMaxRenderTargets + 1> mClearRenderPipelineCache;
+    std::array<RenderPipelineCache, kMaxRenderTargets + 1> mClearRenderPipelineCache { };
 };
 
 class ColorBlitUtils final : angle::NonCopyable
@@ -258,9 +258,9 @@ class ColorBlitUtils final : angle::NonCopyable
     using ColorBlitRenderPipelineCacheArray =
         std::array<std::array<RenderPipelineCache, mtl_shader::kTextureTypeCount>,
                    kMaxRenderTargets>;
-    ColorBlitRenderPipelineCacheArray mBlitRenderPipelineCache;
-    ColorBlitRenderPipelineCacheArray mBlitPremultiplyAlphaRenderPipelineCache;
-    ColorBlitRenderPipelineCacheArray mBlitUnmultiplyAlphaRenderPipelineCache;
+    ColorBlitRenderPipelineCacheArray mBlitRenderPipelineCache {{}};
+    ColorBlitRenderPipelineCacheArray mBlitPremultiplyAlphaRenderPipelineCache {{}};
+    ColorBlitRenderPipelineCacheArray mBlitUnmultiplyAlphaRenderPipelineCache {{}};
 };
 
 class DepthStencilBlitUtils final : angle::NonCopyable
@@ -300,14 +300,14 @@ class DepthStencilBlitUtils final : angle::NonCopyable
         ContextMtl *ctx,
         const StencilBlitViaBufferParams &params);
 
-    std::array<RenderPipelineCache, mtl_shader::kTextureTypeCount> mDepthBlitRenderPipelineCache;
-    std::array<RenderPipelineCache, mtl_shader::kTextureTypeCount> mStencilBlitRenderPipelineCache;
+    std::array<RenderPipelineCache, mtl_shader::kTextureTypeCount> mDepthBlitRenderPipelineCache {};
+    std::array<RenderPipelineCache, mtl_shader::kTextureTypeCount> mStencilBlitRenderPipelineCache {};
     std::array<std::array<RenderPipelineCache, mtl_shader::kTextureTypeCount>,
                mtl_shader::kTextureTypeCount>
-        mDepthStencilBlitRenderPipelineCache;
+        mDepthStencilBlitRenderPipelineCache {{}};
 
     std::array<AutoObjCPtr<id<MTLComputePipelineState>>, mtl_shader::kTextureTypeCount>
-        mStencilBlitToBufferComPipelineCache;
+        mStencilBlitToBufferComPipelineCache {};
 
     // Intermediate buffer for storing copied stencil data. Used when device doesn't support
     // writing stencil in shader.
@@ -417,12 +417,12 @@ class IndexGeneratorUtils final : angle::NonCopyable
                                                  const IndexGenerationParams &params,
                                                  size_t *indicesGenerated);
 
-    IndexConversionPipelineArray mIndexConversionPipelineCaches;
+    IndexConversionPipelineArray mIndexConversionPipelineCaches {{}};
 
-    IndexConversionPipelineArray mTriFanFromElemArrayGeneratorPipelineCaches;
+    IndexConversionPipelineArray mTriFanFromElemArrayGeneratorPipelineCaches {{}};
     AutoObjCPtr<id<MTLComputePipelineState>> mTriFanFromArraysGeneratorPipeline;
 
-    IndexConversionPipelineArray mLineLoopFromElemArrayGeneratorPipelineCaches;
+    IndexConversionPipelineArray mLineLoopFromElemArrayGeneratorPipelineCaches {{}};
     AutoObjCPtr<id<MTLComputePipelineState>> mLineLoopFromArraysGeneratorPipeline;
 };
 
@@ -444,7 +444,7 @@ class VisibilityResultUtils final : angle::NonCopyable
     // Visibility combination compute pipeline:
     // - 0: This compute pipeline only combine the new values and discard old value.
     // - 1: This compute pipeline keep the old value and combine with new values.
-    std::array<AutoObjCPtr<id<MTLComputePipelineState>>, 2> mVisibilityResultCombPipelines;
+    std::array<AutoObjCPtr<id<MTLComputePipelineState>>, 2> mVisibilityResultCombPipelines {};
 };
 
 // Util class for handling mipmap generation
@@ -499,7 +499,7 @@ class CopyPixelsUtils final : angle::NonCopyable
     using PixelsCopyPipelineArray = std::array<
         std::array<AutoObjCPtr<id<MTLComputePipelineState>>, mtl_shader::kTextureTypeCount * 2>,
         angle::kNumANGLEFormats>;
-    PixelsCopyPipelineArray mPixelsCopyPipelineCaches;
+    PixelsCopyPipelineArray mPixelsCopyPipelineCaches {{}};
 
     const std::string mReadShaderName;
     const std::string mWriteShaderName;
@@ -565,8 +565,8 @@ class VertexFormatConversionUtils final : angle::NonCopyable
     using ConvertToFloatRenderPipelineArray =
         std::array<RenderPipelineCache, angle::kNumANGLEFormats>;
 
-    ConvertToFloatCompPipelineArray mConvertToFloatCompPipelineCaches;
-    ConvertToFloatRenderPipelineArray mConvertToFloatRenderPipelineCaches;
+    ConvertToFloatCompPipelineArray mConvertToFloatCompPipelineCaches {};
+    ConvertToFloatRenderPipelineArray mConvertToFloatRenderPipelineCaches {};
 
     AutoObjCPtr<id<MTLComputePipelineState>> mComponentsExpandCompPipeline;
     RenderPipelineCache mComponentsExpandRenderPipelineCache;
diff --git a/src/libANGLE/renderer/metal/mtl_render_utils.mm b/src/libANGLE/renderer/metal/mtl_render_utils.mm
index 9147aa67605d151b8b8f8a40e6bad9889e544171..71fa12b25a115ebdc271acc9f82a50f6d1fa89fe 100644
--- a/src/libANGLE/renderer/metal/mtl_render_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_render_utils.mm
@@ -712,7 +712,8 @@ void DispatchCompute(ContextMtl *contextMtl,
                      id<MTLComputePipelineState> pipelineState,
                      size_t numThreads)
 {
-    NSUInteger w = std::min<NSUInteger>(pipelineState.threadExecutionWidth, numThreads);
+    ASSERT(numThreads != 0);
+    NSUInteger w = std::clamp<NSUInteger>(numThreads, 1u, pipelineState.threadExecutionWidth);
     MTLSize threadsPerThreadgroup = MTLSizeMake(w, 1, 1);
 
     if (contextMtl->getDisplay()->getFeatures().hasNonUniformDispatch.enabled)
@@ -2540,45 +2541,13 @@ angle::Result MipmapUtils::generateMipmapCS(ContextMtl *contextMtl,
                                             bool sRGBMipmap,
                                             NativeTexLevelArray *mipmapOutputViews)
 {
-    // Only support 3D texture for now.
-    ASSERT(srcTexture->textureType() == MTLTextureType3D);
-
     MTLSize threadGroupSize;
     uint32_t slices                             = 1;
     id<MTLComputePipelineState> computePipeline = nil;
-
-    ensure3DMipGeneratorPipelineInitialized(contextMtl);
-    computePipeline = m3DMipGeneratorPipeline;
-    threadGroupSize =
-        MTLSizeMake(kGenerateMipThreadGroupSizePerDim, kGenerateMipThreadGroupSizePerDim,
-                    kGenerateMipThreadGroupSizePerDim);
-
     // The compute shader supports up to 4 mipmaps generated per pass.
     // See shaders/gen_mipmap.metal
     uint32_t maxMipsPerBatch = 4;
 
-    if (threadGroupSize.width * threadGroupSize.height * threadGroupSize.depth >
-            computePipeline.maxTotalThreadsPerThreadgroup ||
-        ANGLE_UNLIKELY(
-            !contextMtl->getDisplay()->getFeatures().allowGenMultipleMipsPerPass.enabled))
-    {
-        // Multiple mipmaps generation is not supported due to hardware's thread group size limits.
-        // Fallback to generate one mip per pass and reduce thread group size.
-        if (ANGLE_UNLIKELY(threadGroupSize.width * threadGroupSize.height >
-                           computePipeline.maxTotalThreadsPerThreadgroup))
-        {
-            // Even with reduced thread group size, we cannot proceed.
-            // HACK: use blit command encoder to generate mipmaps if it is not possible
-            // to use compute shader due to hardware limits.
-            BlitCommandEncoder *blitEncoder = contextMtl->getBlitCommandEncoder();
-            blitEncoder->generateMipmapsForTexture(srcTexture);
-            return angle::Result::Continue;
-        }
-
-        threadGroupSize.depth = 1;
-        maxMipsPerBatch       = 1;
-    }
-
     ComputeCommandEncoder *cmdEncoder = contextMtl->getComputeCommandEncoder();
     ASSERT(cmdEncoder);
 
@@ -2615,8 +2584,29 @@ angle::Result MipmapUtils::generateMipmapCS(ContextMtl *contextMtl,
             UNREACHABLE();
     }
 
-    Generate3DMipmapUniform options;
+    if (threadGroupSize.width * threadGroupSize.height * threadGroupSize.depth >
+            computePipeline.maxTotalThreadsPerThreadgroup ||
+        ANGLE_UNLIKELY(
+            !contextMtl->getDisplay()->getFeatures().allowGenMultipleMipsPerPass.enabled))
+    {
+        // Multiple mipmaps generation is not supported due to hardware's thread group size limits.
+        // Fallback to generate one mip per pass and reduce thread group size.
+        if (ANGLE_UNLIKELY(threadGroupSize.width * threadGroupSize.height >
+                           computePipeline.maxTotalThreadsPerThreadgroup))
+        {
+            // Even with reduced thread group size, we cannot proceed.
+            // HACK: use blit command encoder to generate mipmaps if it is not possible
+            // to use compute shader due to hardware limits.
+            BlitCommandEncoder *blitEncoder = contextMtl->getBlitCommandEncoder();
+            blitEncoder->generateMipmapsForTexture(srcTexture);
+            return angle::Result::Continue;
+        }
+
+        threadGroupSize.depth = 1;
+        maxMipsPerBatch       = 1;
+    }
 
+    Generate3DMipmapUniform options;
     uint32_t remainMips             = srcTexture->mipmapLevels() - 1;
     MipmapNativeLevel batchSrcLevel = kZeroNativeMipLevel;
     options.srcLevel                = batchSrcLevel.get();
diff --git a/src/libANGLE/renderer/metal/mtl_resource_spi.h b/src/libANGLE/renderer/metal/mtl_resource_spi.h
index 3eaa9a64e79af26faa786102ece3f0bdea84d090..7ecb6db9d993df8985fcb6f701dfe7ca75857cae 100644
--- a/src/libANGLE/renderer/metal/mtl_resource_spi.h
+++ b/src/libANGLE/renderer/metal/mtl_resource_spi.h
@@ -1,9 +1,63 @@
-//
-// Copyright 2021 The ANGLE Project Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
+/*
+ * Copyright (C) 2021 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 //
 // mtl_resource_spi.h:
-//    Used to set Metal resource ownership identity with SPI.
-//    Purposefully empty header file. Actual implementation will be hosted in WebKit.
+//    Used to set Metal resource ownership identity with SPI
 //
+
+#ifndef LIBANGLE_RENDERER_METAL_RESOURCE_SPI_H_
+#define LIBANGLE_RENDERER_METAL_RESOURCE_SPI_H_
+
+#import "common/apple/apple_platform.h"
+
+#if ANGLE_USE_METAL_OWNERSHIP_IDENTITY
+
+#    import <Metal/MTLResource_Private.h>
+#    import <Metal/Metal.h>
+#    import <mach/mach_types.h>
+
+namespace rx
+{
+namespace mtl
+{
+inline void setOwnerWithIdentity(id<MTLResource> resource, task_id_token_t identityToken)
+{
+    if (identityToken != TASK_ID_TOKEN_NULL)
+    {
+        kern_return_t kr = [(id<MTLResourceSPI>)resource setOwnerWithIdentity:identityToken];
+        if (ANGLE_UNLIKELY(kr != KERN_SUCCESS))
+        {
+            ERR() << "setOwnerWithIdentity failed with: %s (%x)" << mach_error_string(kr) << kr;
+            ASSERT(false);
+        }
+    }
+    return;
+}
+}  // namespace mtl
+}  // namespace rx
+#endif
+
+#endif /* LIBANGLE_RENDERER_METAL_RESOURCE_SPI_H_ */
diff --git a/src/libANGLE/renderer/metal/mtl_resources.mm b/src/libANGLE/renderer/metal/mtl_resources.mm
index 829539a2e821e01d6aa80729e9eb72cb5ea0e083..2e33c1bea28a7b3cec8a47c84dc6eba5033deb9e 100644
--- a/src/libANGLE/renderer/metal/mtl_resources.mm
+++ b/src/libANGLE/renderer/metal/mtl_resources.mm
@@ -78,12 +78,12 @@ MTLResourceOptions resourceOptionsForStorageMode(MTLStorageMode storageMode)
             return MTLResourceStorageModePrivate;
         case MTLStorageModeMemoryless:
             return MTLResourceStorageModeMemoryless;
-#if TARGET_OS_SIMULATOR
+//#if TARGET_OS_SIMULATOR
         default:
             // TODO(http://anglebug.com/8012): Remove me once hacked SDKs are fixed.
             UNREACHABLE();
             return MTLResourceStorageModeShared;
-#endif
+//#endif
     }
 }
 
diff --git a/src/libANGLE/renderer/metal/mtl_state_cache.mm b/src/libANGLE/renderer/metal/mtl_state_cache.mm
index 6392740b2628a8b9c80a3e4413a958d9bc095d57..10038e18bf871c2ff27fe65f19630b5da61f7404 100644
--- a/src/libANGLE/renderer/metal/mtl_state_cache.mm
+++ b/src/libANGLE/renderer/metal/mtl_state_cache.mm
@@ -21,9 +21,16 @@
 
 #define ANGLE_OBJC_CP_PROPERTY(DST, SRC, PROPERTY) \
     (DST).PROPERTY = static_cast<__typeof__((DST).PROPERTY)>(ToObjC((SRC).PROPERTY))
+#define ANGLE_OBJC_CP_PROPERTY2(DST, SRC, PROPERTY, DST_PROPERTY) \
+    (DST).DST_PROPERTY = static_cast<__typeof__((DST).DST_PROPERTY)>(ToObjC((SRC).PROPERTY))
 
 #define ANGLE_PROP_EQ(LHS, RHS, PROP) ((LHS).PROP == (RHS).PROP)
 
+#if (defined(__MAC_13_0) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_13_0) || \
+    (defined(__IPHONE_16_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_16_0)
+#    define ANGLE_MTL_RENDER_PIPELINE_DESC_RASTER_SAMPLE_COUNT_AVAILABLE 1
+#endif
+
 namespace rx
 {
 namespace mtl
@@ -1016,23 +1023,10 @@ AutoObjCPtr<id<MTLRenderPipelineState>> RenderPipelineCache::createRenderPipelin
 
         auto objCDesc = desc.createMetalDesc(mVertexShader, mFragmentShader);
 
-        // Validate Render Pipeline State:
-        if (DeviceHasMaximumRenderTargetSize(metalDevice))
-        {
-            // TODO: Is the use of NSUInteger in 32 bit systems ok without any overflow checking?
-            NSUInteger maxSize = GetMaxRenderTargetSizeForDeviceInBytes(metalDevice);
-            NSUInteger renderTargetSize =
-                ComputeTotalSizeUsedForMTLRenderPipelineDescriptor(objCDesc, context, metalDevice);
-            if (renderTargetSize > maxSize)
+        if (!ValidateRenderPipelineState(objCDesc, context, metalDevice))
         {
-                std::stringstream errorStream;
-                errorStream << "This set of render targets requires " << renderTargetSize
-                            << " bytes of pixel storage. This device supports " << maxSize
-                            << " bytes.";
-                ANGLE_MTL_HANDLE_ERROR(context, errorStream.str().c_str(), GL_INVALID_OPERATION);
             return nil;
         }
-        }
 
         if (!ValidateRenderPipelineState(objCDesc, context, metalDevice))
         {
diff --git a/src/libANGLE/renderer/metal/mtl_utils.mm b/src/libANGLE/renderer/metal/mtl_utils.mm
index 5dd606d625abaeb53202e71a7bbd2d4eab50280e..55fb5eab341a1230a809f1162d6f9c9d203fc591 100644
--- a/src/libANGLE/renderer/metal/mtl_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_utils.mm
@@ -1492,6 +1492,24 @@ bool SupportsAppleGPUFamily(id<MTLDevice> device, uint8_t appleFamily)
 #endif      // TARGET_OS_IOS || TARGET_OS_TV
 }
 
+#if (defined(__MAC_13_0) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_13_0) ||        \
+    (defined(__IPHONE_16_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_16_0) || \
+    (defined(__TVOS_16_0) && __TV_OS_VERSION_MIN_REQUIRED >= __TVOS_16_0)
+#    define ANGLE_MTL_FEATURE_SET_DEPRECATED 1
+#    define ANGLE_MTL_GPU_FAMILY_MAC1_DEPRECATED 1
+#endif
+
+#if ANGLE_MTL_GPU_FAMILY_MAC1_DEPRECATED
+#    define ANGLE_MTL_GPU_FAMILY_MAC1 MTLGPUFamilyMac2
+#    define ANGLE_MTL_GPU_FAMILY_MAC2 MTLGPUFamilyMac2
+#elif TARGET_OS_MACCATALYST
+#    define ANGLE_MTL_GPU_FAMILY_MAC1 MTLGPUFamilyMacCatalyst1
+#    define ANGLE_MTL_GPU_FAMILY_MAC2 MTLGPUFamilyMacCatalyst2
+#else  // !ANGLE_MTL_GPU_FAMILY_MAC1_DEPRECATED && !TARGET_OS_MACCATALYST
+#    define ANGLE_MTL_GPU_FAMILY_MAC1 MTLGPUFamilyMac1
+#    define ANGLE_MTL_GPU_FAMILY_MAC2 MTLGPUFamilyMac2
+#endif
+
 bool SupportsMacGPUFamily(id<MTLDevice> device, uint8_t macFamily)
 {
 #if TARGET_OS_OSX || TARGET_OS_MACCATALYST
@@ -1506,10 +1524,10 @@ bool SupportsMacGPUFamily(id<MTLDevice> device, uint8_t macFamily)
 #        if TARGET_OS_MACCATALYST
             ANGLE_APPLE_ALLOW_DEPRECATED_BEGIN
             case 1:
-                family = MTLGPUFamilyMacCatalyst1;
+                family = ANGLE_MTL_GPU_FAMILY_MAC1;
                 break;
             case 2:
-                family = MTLGPUFamilyMacCatalyst2;
+                family = ANGLE_MTL_GPU_FAMILY_MAC2;
                 break;
                 ANGLE_APPLE_ALLOW_DEPRECATED_END
 #        else   // TARGET_OS_MACCATALYST
@@ -1532,7 +1550,7 @@ bool SupportsMacGPUFamily(id<MTLDevice> device, uint8_t macFamily)
 
     // If device doesn't support [MTLDevice supportsFamily:], then use
     // [MTLDevice supportsFeatureSet:].
-#    if TARGET_OS_MACCATALYST
+#    if TARGET_OS_MACCATALYST || ANGLE_MTL_FEATURE_SET_DEPRECATED
     UNREACHABLE();
     return false;
 #    else
diff --git a/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py b/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py
new file mode 100644
index 0000000000000000000000000000000000000000..cf99859445a9fa568e346bab94774131127e25d3
--- /dev/null
+++ b/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py
@@ -0,0 +1,76 @@
+#!/usr/bin/python3
+# Copyright 2021 The ANGLE Project Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+#
+# create_mtl_internal_shaders.py:
+#   Script to compile a metalLib into NSData, for including the compilded
+#       library in the ANGLE dylib.
+
+import os
+import sys
+import json
+from datetime import datetime
+
+sys.path.append('../..')
+
+template_header_boilerplate = """// GENERATED FILE - DO NOT EDIT.
+// Generated by {script_name}
+//
+// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+"""
+
+
+# Convert content of a file to byte array and store in a header file.
+# variable_name: name of C++ variable that will hold the file content as byte array.
+# filename: the file whose content will be converted to C++ byte array.
+# dest_src_file: destination header file that will contain the byte array.
+def append_file_as_byte_array_string(variable_name, filename, dest_src_file):
+    string = '// Generated from {0}:\n'.format(filename)
+    string += 'constexpr uint8_t {0}[]={{\n'.format(variable_name)
+    bytes_ = open(filename, "rb").read()
+    for byte in bytes_:
+        string += '0x{:02x}'.format(byte) + ", "
+    string += "\n};\n"
+    with open(dest_src_file, "a") as out_file:
+        out_file.write(string)
+
+
+# Compile metal shader.
+# compiled_file: The compiled metallib
+# variable_name: name of C++ variable that will hold the compiled binary data as a C array.
+# additional_flags: additional shader compiler flags
+# src_files: metal source files
+def gen_precompiled_shaders(compiled_file, variable_name, output_file):
+    append_file_as_byte_array_string(variable_name, compiled_file, output_file)
+    os.system('echo "constexpr size_t {0}_len=sizeof({0});" >> \"{1}\"'.format(
+        variable_name, output_file))
+
+
+def main():
+    input_file = sys.argv[1]
+    output_file = sys.argv[2]
+    os.chdir(sys.path[0])
+
+    boilerplate_code = template_header_boilerplate.format(
+        script_name=os.path.basename(sys.argv[0]), copyright_year=datetime.today().year)
+
+    # -------- Compile shaders -----------
+    # boiler plate code
+    os.system("echo \"{0}\" > \"{1}\"".format(boilerplate_code, output_file))
+    os.system(
+        'echo "// Compiled binary for Metal default shaders.\n\n" >>  \"{0}\"'.format(output_file))
+    os.system('echo "#include <TargetConditionals.h>\n\n" >>  \"{0}\"'.format(output_file))
+
+    os.system('echo "// clang-format off" >> \"{0}\"'.format(output_file))
+
+    gen_precompiled_shaders(input_file, 'gMetalBinaryShaders', output_file)
+
+    os.system('echo "// clang-format on" >> \"{0}\"'.format(output_file))
+
+
+if __name__ == '__main__':
+    sys.exit(main())
diff --git a/src/libANGLE/renderer/metal/shaders/gen_mtl_internal_shaders.py b/src/libANGLE/renderer/metal/shaders/gen_mtl_internal_shaders.py
index 2b9163a47a166e7b0189199b3426ed430817c13e..319a368a5511df14aa2857217d31ba6f9169eff9 100644
--- a/src/libANGLE/renderer/metal/shaders/gen_mtl_internal_shaders.py
+++ b/src/libANGLE/renderer/metal/shaders/gen_mtl_internal_shaders.py
@@ -39,7 +39,7 @@ configs = [{
 }]
 
 metal_source_output_header = "mtl_internal_shaders_src_autogen.h"
-
+metal_source_output_metal = "mtl_internal_shaders_src_autogen.metal"
 template_header_boilerplate = """// GENERATED FILE - DO NOT EDIT.
 // Generated by {script_name}
 //
@@ -204,6 +204,17 @@ def generate_combined_metal_src_header(combined_metal_src, dest_header):
         out_file.close()
 
 
+def generate_combined_metal_file(combined_metal_src, dest_file):
+    boilerplate_code = template_header_boilerplate.format(
+        script_name=os.path.basename(sys.argv[0]))
+    with open(dest_file, 'wt') as out_file:
+        out_file.write(boilerplate_code)
+        out_file.write('\n')
+        out_file.write('// Metal version of combined Metal default shaders.\n\n')
+        out_file.write(combined_metal_src.decode("utf-8"))
+        out_file.close()
+
+
 def main():
     angle_format_script_files = [
         '../../angle_format_map.json', '../../angle_format.py', '../../gen_angle_format_table.py'
@@ -232,6 +243,7 @@ def main():
     combined_metal_src = generate_combined_metal_src(src_files)
 
     generate_combined_metal_src_header(combined_metal_src, metal_source_output_header)
+    generate_combined_metal_file(combined_metal_src, metal_source_output_metal)
 
     for config in configs:
         generate_metallib_header(combined_metal_src, config["sdk"], config["compile_flags"],
diff --git a/src/libANGLE/renderer/metal/shaders/mtl_internal_shaders_src_autogen.metal b/src/libANGLE/renderer/metal/shaders/mtl_internal_shaders_src_autogen.metal
new file mode 100644
index 0000000000000000000000000000000000000000..701cd304c43414054f80522a81cb11a2c2193736
--- /dev/null
+++ b/src/libANGLE/renderer/metal/shaders/mtl_internal_shaders_src_autogen.metal
@@ -0,0 +1,3616 @@
+// GENERATED FILE - DO NOT EDIT.
+// Generated by gen_mtl_internal_shaders.py
+//
+// Copyright 2020 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+// Metal version of combined Metal default shaders.
+
+# 1 "temp_master_source.metal"
+# 1 "<built-in>" 1
+# 1 "<built-in>" 3
+# 399 "<built-in>" 3
+# 1 "<command line>" 1
+# 1 "<built-in>" 2
+# 1 "temp_master_source.metal" 2
+# 1 "./blit.metal" 1
+
+
+
+
+
+
+
+# 1 "./common.h" 1
+# 13 "./common.h"
+# include <simd/simd.h>
+# include <metal_stdlib>
+
+
+# 1 "./constants.h" 1
+# 11 "./constants.h"
+namespace rx
+{
+namespace mtl_shader
+{
+
+enum
+{
+    kTextureType2D = 0,
+    kTextureType2DMultisample = 1,
+    kTextureType2DArray = 2,
+    kTextureTypeCube = 3,
+    kTextureType3D = 4,
+    kTextureTypeCount = 5,
+};
+
+
+
+
+}
+}
+# 18 "./common.h" 2
+
+
+
+
+
+
+
+using namespace metal;
+
+
+
+constant uint32_t kNumColorOutputs [[function_constant(0)]];
+constant bool kColorOutputAvailable0 = kNumColorOutputs > 0;
+constant bool kColorOutputAvailable1 = kNumColorOutputs > 1;
+constant bool kColorOutputAvailable2 = kNumColorOutputs > 2;
+constant bool kColorOutputAvailable3 = kNumColorOutputs > 3;
+constant bool kColorOutputAvailable4 = kNumColorOutputs > 4;
+constant bool kColorOutputAvailable5 = kNumColorOutputs > 5;
+constant bool kColorOutputAvailable6 = kNumColorOutputs > 6;
+constant bool kColorOutputAvailable7 = kNumColorOutputs > 7;
+
+namespace rx
+{
+namespace mtl_shader
+{
+
+
+constant float2 gCorners[3] = {float2(-1.0f, -1.0f), float2(3.0f, -1.0f), float2(-1.0f, 3.0f)};
+
+template <typename T>
+struct MultipleColorOutputs
+{
+    vec<T, 4> color0 [[color(0), function_constant(kColorOutputAvailable0)]];
+    vec<T, 4> color1 [[color(1), function_constant(kColorOutputAvailable1)]];
+    vec<T, 4> color2 [[color(2), function_constant(kColorOutputAvailable2)]];
+    vec<T, 4> color3 [[color(3), function_constant(kColorOutputAvailable3)]];
+    vec<T, 4> color4 [[color(4), function_constant(kColorOutputAvailable4)]];
+    vec<T, 4> color5 [[color(5), function_constant(kColorOutputAvailable5)]];
+    vec<T, 4> color6 [[color(6), function_constant(kColorOutputAvailable6)]];
+    vec<T, 4> color7 [[color(7), function_constant(kColorOutputAvailable7)]];
+};
+# 69 "./common.h"
+template <typename T>
+static inline MultipleColorOutputs<T> toMultipleColorOutputs(vec<T, 4> color)
+{
+    MultipleColorOutputs<T> re;
+
+    do { if (kColorOutputAvailable0) { re.color0 = color; } } while (0);
+    do { if (kColorOutputAvailable1) { re.color1 = color; } } while (0);
+    do { if (kColorOutputAvailable2) { re.color2 = color; } } while (0);
+    do { if (kColorOutputAvailable3) { re.color3 = color; } } while (0);
+    do { if (kColorOutputAvailable4) { re.color4 = color; } } while (0);
+    do { if (kColorOutputAvailable5) { re.color5 = color; } } while (0);
+    do { if (kColorOutputAvailable6) { re.color6 = color; } } while (0);
+    do { if (kColorOutputAvailable7) { re.color7 = color; } } while (0);
+
+    return re;
+}
+
+static inline float3 cubeTexcoords(float2 texcoords, int face)
+{
+    texcoords = 2.0 * texcoords - 1.0;
+    switch (face)
+    {
+        case 0:
+            return float3(1.0, -texcoords.y, -texcoords.x);
+        case 1:
+            return float3(-1.0, -texcoords.y, texcoords.x);
+        case 2:
+            return float3(texcoords.x, 1.0, texcoords.y);
+        case 3:
+            return float3(texcoords.x, -1.0, -texcoords.y);
+        case 4:
+            return float3(texcoords.x, -texcoords.y, 1.0);
+        case 5:
+            return float3(-texcoords.x, -texcoords.y, -1.0);
+    }
+    return float3(texcoords, 0);
+}
+
+template <typename T>
+static inline vec<T, 4> resolveTextureMS(texture2d_ms<T> srcTexture, uint2 coords)
+{
+    uint samples = srcTexture.get_num_samples();
+
+    vec<T, 4> output(0);
+
+    for (uint sample = 0; sample < samples; ++sample)
+    {
+        output += srcTexture.read(coords, sample);
+    }
+
+    output = output / samples;
+
+    return output;
+}
+
+static inline float4 sRGBtoLinear(float4 color)
+{
+    float3 linear1 = color.rgb / 12.92;
+    float3 linear2 = pow((color.rgb + float3(0.055)) / 1.055, 2.4);
+    float3 factor = float3(color.rgb <= float3(0.04045));
+    float4 linear = float4(factor * linear1 + float3(1.0 - factor) * linear2, color.a);
+
+    return linear;
+}
+
+static inline float linearToSRGB(float color)
+{
+    if (color <= 0.0f)
+        return 0.0f;
+    else if (color < 0.0031308f)
+        return 12.92f * color;
+    else if (color < 1.0f)
+        return 1.055f * pow(color, 0.41666f) - 0.055f;
+    else
+        return 1.0f;
+}
+
+static inline float4 linearToSRGB(float4 color)
+{
+    return float4(linearToSRGB(color.r), linearToSRGB(color.g), linearToSRGB(color.b), color.a);
+}
+
+template <typename Short>
+static inline Short bytesToShort(constant uchar *input, uint offset)
+{
+    Short inputLo = input[offset];
+    Short inputHi = input[offset + 1];
+
+    return inputLo | (inputHi << 8);
+}
+
+template <typename Int>
+static inline Int bytesToInt(constant uchar *input, uint offset)
+{
+    Int input0 = input[offset];
+    Int input1 = input[offset + 1];
+    Int input2 = input[offset + 2];
+    Int input3 = input[offset + 3];
+
+    return input0 | (input1 << 8) | (input2 << 16) | (input3 << 24);
+}
+
+template <typename Short>
+static inline void shortToBytes(Short val, uint offset, device uchar *output)
+{
+    ushort valUnsigned = as_type<ushort>(val);
+    output[offset] = valUnsigned & 0xff;
+    output[offset + 1] = (valUnsigned >> 8) & 0xff;
+}
+
+template <typename Int>
+static inline void intToBytes(Int val, uint offset, device uchar *output)
+{
+    uint valUnsigned = as_type<uint>(val);
+    output[offset] = valUnsigned & 0xff;
+    output[offset + 1] = (valUnsigned >> 8) & 0xff;
+    output[offset + 2] = (valUnsigned >> 16) & 0xff;
+    output[offset + 3] = (valUnsigned >> 24) & 0xff;
+}
+
+static inline void floatToBytes(float val, uint offset, device uchar *output)
+{
+    intToBytes(as_type<uint>(val), offset, output);
+}
+
+static inline void int24bitToBytes(uint val, uint offset, device uchar *output)
+{
+    output[offset] = val & 0xff;
+    output[offset + 1] = (val >> 8) & 0xff;
+    output[offset + 2] = (val >> 16) & 0xff;
+}
+
+template <unsigned int inputBitCount, unsigned int inputBitStart, typename T>
+static inline T getShiftedData(T input)
+{
+    static_assert(inputBitCount + inputBitStart <= (sizeof(T) * 8),
+                  "T must have at least as many bits as inputBitCount + inputBitStart.");
+    const T mask = (1 << inputBitCount) - 1;
+    return (input >> inputBitStart) & mask;
+}
+
+template <unsigned int inputBitCount, unsigned int inputBitStart, typename T>
+static inline T shiftData(T input)
+{
+    static_assert(inputBitCount + inputBitStart <= (sizeof(T) * 8),
+                  "T must have at least as many bits as inputBitCount + inputBitStart.");
+    const T mask = (1 << inputBitCount) - 1;
+    return (input & mask) << inputBitStart;
+}
+
+template <unsigned int inputBitCount, typename T>
+static inline float normalizedToFloat(T input)
+{
+    static_assert(inputBitCount <= (sizeof(T) * 8),
+                  "T must have more bits than or same bits as inputBitCount.");
+    static_assert(inputBitCount <= 23, "Only single precision is supported");
+
+    constexpr float inverseMax = 1.0f / ((1 << inputBitCount) - 1);
+    return input * inverseMax;
+}
+
+template <typename T>
+static inline float normalizedToFloat(T input)
+{
+    return normalizedToFloat<sizeof(T) * 8, T>(input);
+}
+
+template <>
+inline float normalizedToFloat(short input)
+{
+    constexpr float inverseMax = 1.0f / 0x7fff;
+    return static_cast<float>(input) * inverseMax;
+}
+
+template <>
+inline float normalizedToFloat(int input)
+{
+    constexpr float inverseMax = 1.0f / 0x7fffffff;
+    return static_cast<float>(input) * inverseMax;
+}
+
+template <>
+inline float normalizedToFloat(uint input)
+{
+    constexpr float inverseMax = 1.0f / 0xffffffff;
+    return static_cast<float>(input) * inverseMax;
+}
+
+template <unsigned int outputBitCount, typename T>
+static inline T floatToNormalized(float input)
+{
+    static_assert(outputBitCount <= (sizeof(T) * 8),
+                  "T must have more bits than or same bits as inputBitCount.");
+    static_assert(outputBitCount <= 23, "Only single precision is supported");
+
+    return static_cast<T>(((1 << outputBitCount) - 1) * input + 0.5f);
+}
+
+template <typename T>
+static inline T floatToNormalized(float input)
+{
+    return floatToNormalized<sizeof(T) * 8, T>(input);
+}
+
+}
+}
+# 9 "./blit.metal" 2
+
+using namespace rx::mtl_shader;
+
+
+constant bool kPremultiplyAlpha [[function_constant(1)]];
+constant bool kUnmultiplyAlpha [[function_constant(2)]];
+constant int kSourceTextureType [[function_constant(3)]];
+constant int kSourceTexture2Type [[function_constant(4)]];
+
+constant bool kSourceTextureType2D = kSourceTextureType == kTextureType2D;
+constant bool kSourceTextureType2DArray = kSourceTextureType == kTextureType2DArray;
+constant bool kSourceTextureType2DMS = kSourceTextureType == kTextureType2DMultisample;
+constant bool kSourceTextureTypeCube = kSourceTextureType == kTextureTypeCube;
+constant bool kSourceTextureType3D = kSourceTextureType == kTextureType3D;
+
+constant bool kSourceTexture2Type2D = kSourceTexture2Type == kTextureType2D;
+constant bool kSourceTexture2Type2DArray = kSourceTexture2Type == kTextureType2DArray;
+constant bool kSourceTexture2Type2DMS = kSourceTexture2Type == kTextureType2DMultisample;
+constant bool kSourceTexture2TypeCube = kSourceTexture2Type == kTextureTypeCube;
+
+struct BlitParams
+{
+
+    float2 srcTexCoords[3];
+    int srcLevel;
+    int srcLayer;
+    bool dstFlipViewportX;
+    bool dstFlipViewportY;
+    bool dstLuminance;
+    uint8_t padding[13];
+};
+
+struct BlitVSOut
+{
+    float4 position [[position]];
+    float2 texCoords [[user(locn1)]];
+};
+
+vertex BlitVSOut blitVS(unsigned int vid [[vertex_id]], constant BlitParams &options [[buffer(0)]])
+{
+    BlitVSOut output;
+    output.position = float4(gCorners[vid], 0.0, 1.0);
+    output.texCoords = options.srcTexCoords[vid];
+
+    if (options.dstFlipViewportX)
+    {
+        output.position.x = -output.position.x;
+    }
+    if (!options.dstFlipViewportY)
+    {
+
+
+        output.position.y = -output.position.y;
+    }
+
+    return output;
+}
+
+template <typename SrcTexture2d>
+static uint2 getImageCoords(SrcTexture2d srcTexture, float2 texCoords)
+{
+    uint2 dimens(srcTexture.get_width(), srcTexture.get_height());
+    uint2 coords = uint2(texCoords * float2(dimens));
+
+    return coords;
+}
+
+template <typename T>
+static inline vec<T, 4> blitSampleTextureMS(texture2d_ms<T> srcTexture, float2 texCoords)
+{
+    uint2 coords = getImageCoords(srcTexture, texCoords);
+    return resolveTextureMS(srcTexture, coords);
+}
+
+template <typename T>
+static inline vec<T, 4> blitSampleTexture3D(texture3d<T> srcTexture,
+                                            sampler textureSampler,
+                                            float2 texCoords,
+                                            constant BlitParams &options)
+{
+    uint depth = srcTexture.get_depth(options.srcLevel);
+    float zCoord = (float(options.srcLayer) + 0.5) / float(depth);
+
+    return srcTexture.sample(textureSampler, float3(texCoords, zCoord), level(options.srcLevel));
+}
+# 112 "./blit.metal"
+template <typename T>
+static inline vec<T, 4> blitReadTexture(BlitVSOut input [[stage_in]], texture2d<T> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<T> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<T> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<T> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<T> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    vec<T, 4> output;
+
+    switch (kSourceTextureType)
+    {
+        case kTextureType2D:
+            output = srcTexture2d.sample(textureSampler, input.texCoords, level(options.srcLevel));
+            break;
+        case kTextureType2DArray:
+            output = srcTexture2dArray.sample(textureSampler, input.texCoords, options.srcLayer,
+                                              level(options.srcLevel));
+            break;
+        case kTextureType2DMultisample:
+            output = blitSampleTextureMS(srcTexture2dMS, input.texCoords);
+            break;
+        case kTextureTypeCube:
+            output = srcTextureCube.sample(textureSampler,
+                                           cubeTexcoords(input.texCoords, options.srcLayer),
+                                           level(options.srcLevel));
+            break;
+        case kTextureType3D:
+            output = blitSampleTexture3D(srcTexture3d, textureSampler, input.texCoords, options);
+            break;
+    }
+
+    if (kPremultiplyAlpha)
+    {
+        output.xyz *= output.a;
+    }
+    else if (kUnmultiplyAlpha)
+    {
+        if (output.a != 0.0)
+        {
+            output.xyz /= output.a;
+        }
+    }
+
+    if (options.dstLuminance)
+    {
+        output.g = output.b = output.r;
+    }
+
+    return output;
+}
+
+template <typename T>
+static inline MultipleColorOutputs<T> blitFS(BlitVSOut input [[stage_in]], texture2d<T> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<T> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<T> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<T> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<T> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    vec<T, 4> output = blitReadTexture(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+
+    return toMultipleColorOutputs(output);
+}
+
+fragment MultipleColorOutputs<float> blitFloatFS(BlitVSOut input [[stage_in]], texture2d<float> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<float> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<float> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<float> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<float> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    return blitFS(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+}
+fragment MultipleColorOutputs<int> blitIntFS(BlitVSOut input [[stage_in]], texture2d<int> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<int> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<int> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<int> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<int> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    return blitFS(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+}
+fragment MultipleColorOutputs<uint> blitUIntFS(BlitVSOut input [[stage_in]], texture2d<uint> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<uint> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<uint> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<uint> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<uint> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    return blitFS(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+}
+
+fragment MultipleColorOutputs<uint> copyTextureFloatToUIntFS(BlitVSOut input [[stage_in]], texture2d<float> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<float> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<float> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<float> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<float> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    float4 inputColor = blitReadTexture<>(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+    uint4 output = uint4(inputColor * float4(255.0));
+
+    return toMultipleColorOutputs(output);
+}
+
+
+struct FragmentDepthOut
+{
+    float depth [[depth(any)]];
+};
+
+static inline float sampleDepth(
+    texture2d<float> srcTexture2d [[function_constant(kSourceTextureType2D)]],
+    texture2d_array<float> srcTexture2dArray [[function_constant(kSourceTextureType2DArray)]],
+    texture2d_ms<float> srcTexture2dMS [[function_constant(kSourceTextureType2DMS)]],
+    texturecube<float> srcTextureCube [[function_constant(kSourceTextureTypeCube)]],
+    float2 texCoords,
+    constant BlitParams &options)
+{
+    float4 output;
+
+    constexpr sampler textureSampler(mag_filter::nearest, min_filter::nearest);
+
+    switch (kSourceTextureType)
+    {
+        case kTextureType2D:
+            output = srcTexture2d.sample(textureSampler, texCoords, level(options.srcLevel));
+            break;
+        case kTextureType2DArray:
+            output = srcTexture2dArray.sample(textureSampler, texCoords, options.srcLayer,
+                                              level(options.srcLevel));
+            break;
+        case kTextureType2DMultisample:
+
+            output = srcTexture2dMS.read(getImageCoords(srcTexture2dMS, texCoords), 0);
+            break;
+        case kTextureTypeCube:
+            output =
+                srcTextureCube.sample(textureSampler, cubeTexcoords(texCoords, options.srcLayer),
+                                      level(options.srcLevel));
+            break;
+    }
+
+    return output.r;
+}
+
+fragment FragmentDepthOut blitDepthFS(BlitVSOut input [[stage_in]],
+                                      texture2d<float> srcTexture2d
+                                      [[texture(0), function_constant(kSourceTextureType2D)]],
+                                      texture2d_array<float> srcTexture2dArray
+                                      [[texture(0), function_constant(kSourceTextureType2DArray)]],
+                                      texture2d_ms<float> srcTexture2dMS
+                                      [[texture(0), function_constant(kSourceTextureType2DMS)]],
+                                      texturecube<float> srcTextureCube
+                                      [[texture(0), function_constant(kSourceTextureTypeCube)]],
+                                      constant BlitParams &options [[buffer(0)]])
+{
+    FragmentDepthOut re;
+
+    re.depth = sampleDepth(srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube,
+                           input.texCoords, options);
+
+    return re;
+}
+
+static inline uint32_t sampleStencil(
+    texture2d<uint32_t> srcTexture2d [[function_constant(kSourceTexture2Type2D)]],
+    texture2d_array<uint32_t> srcTexture2dArray [[function_constant(kSourceTexture2Type2DArray)]],
+    texture2d_ms<uint32_t> srcTexture2dMS [[function_constant(kSourceTexture2Type2DMS)]],
+    texturecube<uint32_t> srcTextureCube [[function_constant(kSourceTexture2TypeCube)]],
+    float2 texCoords,
+    int srcLevel,
+    int srcLayer)
+{
+    uint4 output;
+    constexpr sampler textureSampler(mag_filter::nearest, min_filter::nearest);
+
+    switch (kSourceTexture2Type)
+    {
+        case kTextureType2D:
+            output = srcTexture2d.sample(textureSampler, texCoords, level(srcLevel));
+            break;
+        case kTextureType2DArray:
+            output = srcTexture2dArray.sample(textureSampler, texCoords, srcLayer, level(srcLevel));
+            break;
+        case kTextureType2DMultisample:
+
+            output = srcTexture2dMS.read(getImageCoords(srcTexture2dMS, texCoords), 0);
+            break;
+        case kTextureTypeCube:
+            output = srcTextureCube.sample(textureSampler, cubeTexcoords(texCoords, srcLayer),
+                                           level(srcLevel));
+            break;
+    }
+
+    return output.r;
+}
+
+
+struct BlitStencilToBufferParams
+{
+    float2 srcStartTexCoords;
+    float2 srcTexCoordSteps;
+    int srcLevel;
+    int srcLayer;
+
+    uint2 dstSize;
+    uint dstBufferRowPitch;
+
+    bool resolveMS;
+};
+
+kernel void blitStencilToBufferCS(ushort2 gIndices [[thread_position_in_grid]],
+                                  texture2d<uint32_t> srcTexture2d
+                                  [[texture(1), function_constant(kSourceTexture2Type2D)]],
+                                  texture2d_array<uint32_t> srcTexture2dArray
+                                  [[texture(1), function_constant(kSourceTexture2Type2DArray)]],
+                                  texture2d_ms<uint32_t> srcTexture2dMS
+                                  [[texture(1), function_constant(kSourceTexture2Type2DMS)]],
+                                  texturecube<uint32_t> srcTextureCube
+                                  [[texture(1), function_constant(kSourceTexture2TypeCube)]],
+                                  constant BlitStencilToBufferParams &options [[buffer(0)]],
+                                  device uchar *buffer [[buffer(1)]])
+{
+    if (gIndices.x >= options.dstSize.x || gIndices.y >= options.dstSize.y)
+    {
+        return;
+    }
+
+    float2 srcTexCoords = options.srcStartTexCoords + float2(gIndices) * options.srcTexCoordSteps;
+
+    if (kSourceTexture2Type == kTextureType2DMultisample && !options.resolveMS)
+    {
+        uint samples = srcTexture2dMS.get_num_samples();
+        uint2 imageCoords = getImageCoords(srcTexture2dMS, srcTexCoords);
+        uint bufferOffset = options.dstBufferRowPitch * gIndices.y + samples * gIndices.x;
+
+        for (uint sample = 0; sample < samples; ++sample)
+        {
+            uint stencilPerSample = srcTexture2dMS.read(imageCoords, sample).r;
+            buffer[bufferOffset + sample] = static_cast<uchar>(stencilPerSample);
+        }
+    }
+    else
+    {
+        uint32_t stencil =
+            sampleStencil(srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube,
+                          srcTexCoords, options.srcLevel, options.srcLayer);
+
+        buffer[options.dstBufferRowPitch * gIndices.y + gIndices.x] = static_cast<uchar>(stencil);
+    }
+}
+
+
+#if __METAL_VERSION__ >= 210
+
+struct FragmentStencilOut
+{
+    uint32_t stencil [[stencil]];
+};
+
+struct FragmentDepthStencilOut
+{
+    float depth [[depth(any)]];
+    uint32_t stencil [[stencil]];
+};
+
+fragment FragmentStencilOut blitStencilFS(
+    BlitVSOut input [[stage_in]],
+    texture2d<uint32_t> srcTexture2d [[texture(1), function_constant(kSourceTexture2Type2D)]],
+    texture2d_array<uint32_t> srcTexture2dArray
+    [[texture(1), function_constant(kSourceTexture2Type2DArray)]],
+    texture2d_ms<uint32_t> srcTexture2dMS
+    [[texture(1), function_constant(kSourceTexture2Type2DMS)]],
+    texturecube<uint32_t> srcTextureCube [[texture(1), function_constant(kSourceTexture2TypeCube)]],
+    constant BlitParams &options [[buffer(0)]])
+{
+    FragmentStencilOut re;
+
+    re.stencil = sampleStencil(srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube,
+                               input.texCoords, options.srcLevel, options.srcLayer);
+
+    return re;
+}
+
+fragment FragmentDepthStencilOut blitDepthStencilFS(
+    BlitVSOut input [[stage_in]],
+
+    texture2d<float> srcDepthTexture2d [[texture(0), function_constant(kSourceTextureType2D)]],
+    texture2d_array<float> srcDepthTexture2dArray
+    [[texture(0), function_constant(kSourceTextureType2DArray)]],
+    texture2d_ms<float> srcDepthTexture2dMS
+    [[texture(0), function_constant(kSourceTextureType2DMS)]],
+    texturecube<float> srcDepthTextureCube
+    [[texture(0), function_constant(kSourceTextureTypeCube)]],
+
+
+    texture2d<uint32_t> srcStencilTexture2d
+    [[texture(1), function_constant(kSourceTexture2Type2D)]],
+    texture2d_array<uint32_t> srcStencilTexture2dArray
+    [[texture(1), function_constant(kSourceTexture2Type2DArray)]],
+    texture2d_ms<uint32_t> srcStencilTexture2dMS
+    [[texture(1), function_constant(kSourceTexture2Type2DMS)]],
+    texturecube<uint32_t> srcStencilTextureCube
+    [[texture(1), function_constant(kSourceTexture2TypeCube)]],
+
+    constant BlitParams &options [[buffer(0)]])
+{
+    FragmentDepthStencilOut re;
+
+    re.depth = sampleDepth(srcDepthTexture2d, srcDepthTexture2dArray, srcDepthTexture2dMS,
+                           srcDepthTextureCube, input.texCoords, options);
+    re.stencil =
+        sampleStencil(srcStencilTexture2d, srcStencilTexture2dArray, srcStencilTexture2dMS,
+                      srcStencilTextureCube, input.texCoords, options.srcLevel, options.srcLayer);
+    return re;
+}
+#endif
+# 2 "temp_master_source.metal" 2
+# 1 "./clear.metal" 1
+# 10 "./clear.metal"
+using namespace rx::mtl_shader;
+
+struct ClearParams
+{
+    float4 clearColor;
+    float clearDepth;
+};
+
+vertex float4 clearVS(unsigned int vid [[ vertex_id ]],
+                      constant ClearParams &clearParams [[buffer(0)]])
+{
+    return float4(gCorners[vid], clearParams.clearDepth, 1.0);
+}
+
+fragment MultipleColorOutputs<float> clearFloatFS(constant ClearParams &clearParams [[buffer(0)]])
+{
+    return toMultipleColorOutputs(clearParams.clearColor);
+}
+
+fragment MultipleColorOutputs<int> clearIntFS(constant ClearParams &clearParams [[buffer(0)]])
+{
+    return toMultipleColorOutputs(as_type<int4>(clearParams.clearColor));
+}
+
+fragment MultipleColorOutputs<uint> clearUIntFS(constant ClearParams &clearParams [[buffer(0)]])
+{
+    return toMultipleColorOutputs(as_type<uint4>(clearParams.clearColor));
+}
+# 3 "temp_master_source.metal" 2
+# 1 "./gen_indices.metal" 1
+
+
+
+
+
+
+
+
+using namespace rx::mtl_shader;
+
+
+constant bool kSourceBufferAligned[[function_constant(100)]];
+constant bool kSourceIndexIsU8[[function_constant(200)]];
+constant bool kSourceIndexIsU16[[function_constant(300)]];
+constant bool kSourceIndexIsU32[[function_constant(400)]];
+constant bool kSourceBufferUnaligned = !kSourceBufferAligned;
+constant bool kUseSourceBufferU8 = kSourceIndexIsU8 || kSourceBufferUnaligned;
+constant bool kUseSourceBufferU16 = kSourceIndexIsU16 && kSourceBufferAligned;
+constant bool kUseSourceBufferU32 = kSourceIndexIsU32 && kSourceBufferAligned;
+
+struct IndexConversionParams
+{
+    uint32_t srcOffset;
+    uint32_t indexCount;
+    bool primitiveRestartEnabled;
+};
+
+
+
+inline ushort getIndexAligned(constant ushort *inputAligned, uint offset, uint idx)
+{
+    return inputAligned[offset / 2 + idx];
+}
+inline uint getIndexAligned(constant uint *inputAligned, uint offset, uint idx)
+{
+    return inputAligned[offset / 4 + idx];
+}
+inline uchar getIndexAligned(constant uchar *input, uint offset, uint idx)
+{
+    return input[offset + idx];
+}
+inline ushort getIndexUnalignedU16(constant uchar *input, uint offset, uint idx)
+{
+    ushort inputLo = input[offset + 2 * idx];
+    ushort inputHi = input[offset + 2 * idx + 1];
+
+    return inputLo | (inputHi << 8);
+}
+inline uint getIndexUnalignedU32(constant uchar *input, uint offset, uint idx)
+{
+    uint input0 = input[offset + 4 * idx];
+    uint input1 = input[offset + 4 * idx + 1];
+    uint input2 = input[offset + 4 * idx + 2];
+    uint input3 = input[offset + 4 * idx + 3];
+
+    return input0 | (input1 << 8) | (input2 << 16) | (input3 << 24);
+}
+
+kernel void convertIndexU8ToU16(uint idx [[thread_position_in_grid]],
+                                constant IndexConversionParams &options [[buffer(0)]],
+                                constant uchar *input [[buffer(1)]],
+                                device ushort *output [[buffer(2)]])
+{
+    if (idx >= options.indexCount) { return; };
+
+    uchar value = getIndexAligned(input, options.srcOffset, idx);
+
+    if (options.primitiveRestartEnabled && value == 0xff)
+    {
+        output[idx] = 0xffff;
+    }
+    else
+    {
+        output[idx] = value;
+    }
+}
+
+kernel void convertIndexU16(uint idx [[thread_position_in_grid]],
+                            constant IndexConversionParams &options [[buffer(0)]],
+                            constant uchar *input
+                            [[buffer(1), function_constant(kSourceBufferUnaligned)]],
+                            constant ushort *inputAligned
+                            [[buffer(1), function_constant(kSourceBufferAligned)]],
+                            device ushort *output [[buffer(2)]])
+{
+    if (idx >= options.indexCount) { return; };
+
+    ushort value;
+    if (kSourceBufferAligned)
+    {
+        value = getIndexAligned(inputAligned, options.srcOffset, idx);
+    }
+    else
+    {
+        value = getIndexUnalignedU16(input, options.srcOffset, idx);
+    }
+    output[idx] = value;
+}
+
+kernel void convertIndexU32(uint idx [[thread_position_in_grid]],
+                            constant IndexConversionParams &options [[buffer(0)]],
+                            constant uchar *input
+                            [[buffer(1), function_constant(kSourceBufferUnaligned)]],
+                            constant uint *inputAligned
+                            [[buffer(1), function_constant(kSourceBufferAligned)]],
+                            device uint *output [[buffer(2)]])
+{
+    if (idx >= options.indexCount) { return; };
+
+    uint value;
+    if (kSourceBufferAligned)
+    {
+        value = getIndexAligned(inputAligned, options.srcOffset, idx);
+    }
+    else
+    {
+        value = getIndexUnalignedU32(input, options.srcOffset, idx);
+    }
+    output[idx] = value;
+}
+
+struct IndexFromArrayParams
+{
+    uint firstVertex;
+
+    uint vertexCount;
+};
+
+
+kernel void genTriFanIndicesFromArray(uint idx [[thread_position_in_grid]],
+                                      constant IndexFromArrayParams &options [[buffer(0)]],
+                                      device uint *output [[buffer(2)]])
+{
+    if (idx >= options.vertexCount) { return; };
+
+    uint vertexIdx = options.firstVertex + 2 + idx;
+
+
+
+    output[3 * idx ] = vertexIdx - 1;
+    output[3 * idx + 1] = vertexIdx;
+    output[3 * idx + 2] = options.firstVertex;
+}
+
+inline uint getIndexU32(uint offset,
+                        uint idx,
+                        constant uchar *inputU8 [[function_constant(kUseSourceBufferU8)]],
+                        constant ushort *inputU16 [[function_constant(kUseSourceBufferU16)]],
+                        constant uint *inputU32 [[function_constant(kUseSourceBufferU32)]])
+{
+    if (kUseSourceBufferU8)
+    {
+        if (kSourceIndexIsU16)
+        {
+            return getIndexUnalignedU16(inputU8, offset, idx);
+        }
+        else if (kSourceIndexIsU32)
+        {
+            return getIndexUnalignedU32(inputU8, offset, idx);
+        }
+        return getIndexAligned(inputU8, offset, idx);
+    }
+    else if (kUseSourceBufferU16)
+    {
+        return getIndexAligned(inputU16, offset, idx);
+    }
+    else if (kUseSourceBufferU32)
+    {
+        return getIndexAligned(inputU32, offset, idx);
+    }
+    return 0;
+}
+
+
+
+
+kernel void genTriFanIndicesFromElements(uint idx [[thread_position_in_grid]],
+                                         constant IndexConversionParams &options [[buffer(0)]],
+                                         constant uchar *inputU8
+                                         [[buffer(1), function_constant(kUseSourceBufferU8)]],
+                                         constant ushort *inputU16
+                                         [[buffer(1), function_constant(kUseSourceBufferU16)]],
+                                         constant uint *inputU32
+                                         [[buffer(1), function_constant(kUseSourceBufferU32)]],
+                                         device uint *output [[buffer(2)]])
+{
+    if (idx >= options.indexCount) { return; };
+
+    uint elemIdx = 2 + idx;
+
+    output[3 * idx] = getIndexU32(options.srcOffset, 0, inputU8, inputU16, inputU32);
+    output[3 * idx + 1] = getIndexU32(options.srcOffset, elemIdx - 1, inputU8, inputU16, inputU32);
+    output[3 * idx + 2] = getIndexU32(options.srcOffset, elemIdx, inputU8, inputU16, inputU32);
+}
+
+
+kernel void genLineLoopIndicesFromArray(uint idx [[thread_position_in_grid]],
+                                        constant IndexFromArrayParams &options [[buffer(0)]],
+                                        device uint *output [[buffer(2)]])
+{
+    uint totalIndices = options.vertexCount + 1;
+    if (idx >= totalIndices) { return; };
+
+    output[idx] = options.firstVertex + idx % options.vertexCount;
+}
+
+
+
+kernel void genLineLoopIndicesFromElements(uint idx [[thread_position_in_grid]],
+                                           constant IndexConversionParams &options [[buffer(0)]],
+                                           constant uchar *inputU8
+                                           [[buffer(1), function_constant(kUseSourceBufferU8)]],
+                                           constant ushort *inputU16
+                                           [[buffer(1), function_constant(kUseSourceBufferU16)]],
+                                           constant uint *inputU32
+                                           [[buffer(1), function_constant(kUseSourceBufferU32)]],
+                                           device uint *output [[buffer(2)]])
+{
+    uint totalTargetIndices = options.indexCount + 1;
+    if (idx >= totalTargetIndices) { return; };
+
+    output[idx] =
+        getIndexU32(options.srcOffset, idx % options.indexCount, inputU8, inputU16, inputU32);
+}
+# 4 "temp_master_source.metal" 2
+# 1 "./gen_mipmap.metal" 1
+
+
+
+
+
+
+
+
+using namespace rx::mtl_shader;
+# 31 "./gen_mipmap.metal"
+struct GenMipParams
+{
+    uint srcLevel;
+    uint numMipLevelsToGen;
+    bool sRGB;
+};
+
+
+
+kernel void generate3DMipmaps(uint lIndex [[thread_index_in_threadgroup]],
+                              ushort3 gIndices [[thread_position_in_grid]],
+                              texture3d<float> srcTexture [[texture(0)]],
+                              texture3d<float, access::write> dstMip1 [[texture(1)]],
+                              texture3d<float, access::write> dstMip2 [[texture(2)]],
+                              texture3d<float, access::write> dstMip3 [[texture(3)]],
+                              texture3d<float, access::write> dstMip4 [[texture(4)]],
+                              constant GenMipParams &options [[buffer(0)]])
+{
+    ushort3 mipSize = ushort3(dstMip1.get_width(), dstMip1.get_height(), dstMip1.get_depth());
+    bool validThread = gIndices.x < mipSize.x && gIndices.y < mipSize.y && gIndices.z < mipSize.z;
+
+    constexpr sampler textureSampler(mag_filter::linear, min_filter::linear, mip_filter::linear);
+
+
+
+
+    threadgroup float sR[(8 * 8 * 8)];
+    threadgroup float sG[(8 * 8 * 8)];
+    threadgroup float sB[(8 * 8 * 8)];
+    threadgroup float sA[(8 * 8 * 8)];
+
+
+    float4 texel1;
+    if (validThread)
+    {
+        float3 texCoords = (float3(gIndices) + float3(0.5, 0.5, 0.5)) / float3(mipSize);
+        texel1 = srcTexture.sample(textureSampler, texCoords, level(options.srcLevel));
+
+
+        dstMip1.write(texel1, gIndices);
+    }
+    else
+    {
+
+        lIndex = 0xffffffff;
+    }
+
+    if (options.numMipLevelsToGen == 1)
+    {
+        return;
+    }
+
+
+
+
+    if (options.sRGB)
+    {
+        texel1 = linearToSRGB(texel1);
+    }
+    sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x49) == 0)
+    {
+        bool3 atEdge = gIndices == (mipSize - ushort3(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 1], sG[lIndex + 1], sB[lIndex + 1], sA[lIndex + 1]));
+
+        float4 texel3 = (atEdge.y) ? (texel1) : (float4(sR[lIndex + 8], sG[lIndex + 8], sB[lIndex + 8], sA[lIndex + 8]));
+
+        float4 texel4 = (atEdge.z) ? (texel1) : (float4(sR[lIndex + (8 * 8)], sG[lIndex + (8 * 8)], sB[lIndex + (8 * 8)], sA[lIndex + (8 * 8)]));
+
+        float4 texel5 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (8 + 1)], sG[lIndex + (8 + 1)], sB[lIndex + (8 + 1)], sA[lIndex + (8 + 1)]));
+
+
+        float4 texel6 = (atEdge.x | atEdge.z) ? (texel2) : (float4(sR[lIndex + ((8 * 8) + 1)], sG[lIndex + ((8 * 8) + 1)], sB[lIndex + ((8 * 8) + 1)], sA[lIndex + ((8 * 8) + 1)]));
+
+
+        float4 texel7 = (atEdge.y | atEdge.z) ? (texel3) : (float4(sR[lIndex + ((8 * 8) + 8)], sG[lIndex + ((8 * 8) + 8)], sB[lIndex + ((8 * 8) + 8)], sA[lIndex + ((8 * 8) + 8)]));
+
+
+        float4 texel8 =
+            (atEdge.x | atEdge.y | atEdge.z) ? (texel5) : (float4(sR[lIndex + ((8 * 8) + 8 + 1)], sG[lIndex + ((8 * 8) + 8 + 1)], sB[lIndex + ((8 * 8) + 8 + 1)], sA[lIndex + ((8 * 8) + 8 + 1)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4 + texel5 + texel6 + texel7 + texel8) / 8.0;
+
+        dstMip2.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 1);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 2)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0xdb) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort3(1));
+        bool3 atEdge = (gIndices >> 1) == (mipSize - ushort3(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 2], sG[lIndex + 2], sB[lIndex + 2], sA[lIndex + 2]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + (2 * 8)], sG[lIndex + (2 * 8)], sB[lIndex + (2 * 8)], sA[lIndex + (2 * 8)]));
+
+        float4 texel4 =
+            (atEdge.z) ? (texel1) : (float4(sR[lIndex + (2 * (8 * 8))], sG[lIndex + (2 * (8 * 8))], sB[lIndex + (2 * (8 * 8))], sA[lIndex + (2 * (8 * 8))]));
+
+        float4 texel5 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (2 * 8 + 2)], sG[lIndex + (2 * 8 + 2)], sB[lIndex + (2 * 8 + 2)], sA[lIndex + (2 * 8 + 2)]));
+
+
+        float4 texel6 = (atEdge.x | atEdge.z) ? (texel2) : (float4(sR[lIndex + (2 * (8 * 8) + 2)], sG[lIndex + (2 * (8 * 8) + 2)], sB[lIndex + (2 * (8 * 8) + 2)], sA[lIndex + (2 * (8 * 8) + 2)]));
+
+
+        float4 texel7 = (atEdge.y | atEdge.z) ? (texel3) : (float4(sR[lIndex + (2 * (8 * 8) + 2 * 8)], sG[lIndex + (2 * (8 * 8) + 2 * 8)], sB[lIndex + (2 * (8 * 8) + 2 * 8)], sA[lIndex + (2 * (8 * 8) + 2 * 8)]));
+
+
+
+        float4 texel8 = (atEdge.x | atEdge.y | atEdge.z) ? (texel5) : (float4(sR[lIndex + (2 * (8 * 8) + 2 * 8 + 2)], sG[lIndex + (2 * (8 * 8) + 2 * 8 + 2)], sB[lIndex + (2 * (8 * 8) + 2 * 8 + 2)], sA[lIndex + (2 * (8 * 8) + 2 * 8 + 2)]));
+
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4 + texel5 + texel6 + texel7 + texel8) / 8.0;
+
+        dstMip3.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 2);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 3)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x1ff) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort3(1));
+        bool3 atEdge = (gIndices >> 2) == (mipSize - ushort3(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 4], sG[lIndex + 4], sB[lIndex + 4], sA[lIndex + 4]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + (4 * 8)], sG[lIndex + (4 * 8)], sB[lIndex + (4 * 8)], sA[lIndex + (4 * 8)]));
+
+        float4 texel4 =
+            (atEdge.z) ? (texel1) : (float4(sR[lIndex + (4 * (8 * 8))], sG[lIndex + (4 * (8 * 8))], sB[lIndex + (4 * (8 * 8))], sA[lIndex + (4 * (8 * 8))]));
+
+        float4 texel5 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (4 * 8 + 4)], sG[lIndex + (4 * 8 + 4)], sB[lIndex + (4 * 8 + 4)], sA[lIndex + (4 * 8 + 4)]));
+
+
+        float4 texel6 = (atEdge.x | atEdge.z) ? (texel2) : (float4(sR[lIndex + (4 * (8 * 8) + 4)], sG[lIndex + (4 * (8 * 8) + 4)], sB[lIndex + (4 * (8 * 8) + 4)], sA[lIndex + (4 * (8 * 8) + 4)]));
+
+
+        float4 texel7 = (atEdge.y | atEdge.z) ? (texel3) : (float4(sR[lIndex + (4 * (8 * 8) + 4 * 8)], sG[lIndex + (4 * (8 * 8) + 4 * 8)], sB[lIndex + (4 * (8 * 8) + 4 * 8)], sA[lIndex + (4 * (8 * 8) + 4 * 8)]));
+
+
+
+        float4 texel8 = (atEdge.x | atEdge.y | atEdge.z) ? (texel5) : (float4(sR[lIndex + (4 * (8 * 8) + 4 * 8 + 4)], sG[lIndex + (4 * (8 * 8) + 4 * 8 + 4)], sB[lIndex + (4 * (8 * 8) + 4 * 8 + 4)], sA[lIndex + (4 * (8 * 8) + 4 * 8 + 4)]));
+
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4 + texel5 + texel6 + texel7 + texel8) / 8.0;
+
+        dstMip4.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 3);
+    }
+}
+
+kernel void generate2DMipmaps(uint lIndex [[thread_index_in_threadgroup]],
+                              ushort2 gIndices [[thread_position_in_grid]],
+                              texture2d<float> srcTexture [[texture(0)]],
+                              texture2d<float, access::write> dstMip1 [[texture(1)]],
+                              texture2d<float, access::write> dstMip2 [[texture(2)]],
+                              texture2d<float, access::write> dstMip3 [[texture(3)]],
+                              texture2d<float, access::write> dstMip4 [[texture(4)]],
+                              constant GenMipParams &options [[buffer(0)]])
+{
+    uint firstMipLevel = options.srcLevel + 1;
+    ushort2 mipSize =
+        ushort2(srcTexture.get_width(firstMipLevel), srcTexture.get_height(firstMipLevel));
+    bool validThread = gIndices.x < mipSize.x && gIndices.y < mipSize.y;
+
+    constexpr sampler textureSampler(mag_filter::linear, min_filter::linear, mip_filter::linear);
+
+
+
+
+    threadgroup float sR[(8 * 8)];
+    threadgroup float sG[(8 * 8)];
+    threadgroup float sB[(8 * 8)];
+    threadgroup float sA[(8 * 8)];
+
+
+    float4 texel1;
+    if (validThread)
+    {
+        float2 texCoords = (float2(gIndices) + float2(0.5, 0.5)) / float2(mipSize);
+        texel1 = srcTexture.sample(textureSampler, texCoords, level(options.srcLevel));
+
+
+        dstMip1.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices);
+    }
+    else
+    {
+
+        lIndex = 0xffffffff;
+    }
+
+    if (options.numMipLevelsToGen == 1)
+    {
+        return;
+    }
+
+
+
+
+    sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x09) == 0)
+    {
+        bool2 atEdge = gIndices == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 1], sG[lIndex + 1], sB[lIndex + 1], sA[lIndex + 1]));
+
+        float4 texel3 = (atEdge.y) ? (texel1) : (float4(sR[lIndex + 8], sG[lIndex + 8], sB[lIndex + 8], sA[lIndex + 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (8 + 1)], sG[lIndex + (8 + 1)], sB[lIndex + (8 + 1)], sA[lIndex + (8 + 1)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip2.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 1);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 2)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x1b) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort2(1));
+        bool2 atEdge = (gIndices >> 1) == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 2], sG[lIndex + 2], sB[lIndex + 2], sA[lIndex + 2]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + 2 * 8], sG[lIndex + 2 * 8], sB[lIndex + 2 * 8], sA[lIndex + 2 * 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (2 * 8 + 2)], sG[lIndex + (2 * 8 + 2)], sB[lIndex + (2 * 8 + 2)], sA[lIndex + (2 * 8 + 2)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip3.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 2);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 3)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x3f) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort2(1));
+        bool2 atEdge = (gIndices >> 2) == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 4], sG[lIndex + 4], sB[lIndex + 4], sA[lIndex + 4]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + 4 * 8], sG[lIndex + 4 * 8], sB[lIndex + 4 * 8], sA[lIndex + 4 * 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (4 * 8 + 4)], sG[lIndex + (4 * 8 + 4)], sB[lIndex + (4 * 8 + 4)], sA[lIndex + (4 * 8 + 4)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip4.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 3);
+    }
+}
+
+template <typename TextureTypeR, typename TextureTypeW>
+static __attribute__((always_inline)) void generateCubeOr2DArray2ndAndMoreMipmaps(
+    uint lIndex,
+    ushort3 gIndices,
+    TextureTypeR srcTexture,
+    TextureTypeW dstMip2,
+    TextureTypeW dstMip3,
+    TextureTypeW dstMip4,
+    ushort2 mip1Size,
+    float4 mip1Texel,
+    threadgroup float *sR,
+    threadgroup float *sG,
+    threadgroup float *sB,
+    threadgroup float *sA,
+    constant GenMipParams &options)
+{
+    ushort2 mipSize = mip1Size;
+    float4 texel1 = mip1Texel;
+
+
+
+
+    sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x09) == 0)
+    {
+        bool2 atEdge = gIndices.xy == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 1], sG[lIndex + 1], sB[lIndex + 1], sA[lIndex + 1]));
+
+        float4 texel3 = (atEdge.y) ? (texel1) : (float4(sR[lIndex + 8], sG[lIndex + 8], sB[lIndex + 8], sA[lIndex + 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (8 + 1)], sG[lIndex + (8 + 1)], sB[lIndex + (8 + 1)], sA[lIndex + (8 + 1)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip2.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices.xy >> 1, gIndices.z);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 2)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x1b) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort2(1));
+        bool2 atEdge = (gIndices.xy >> 1) == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 2], sG[lIndex + 2], sB[lIndex + 2], sA[lIndex + 2]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + 2 * 8], sG[lIndex + 2 * 8], sB[lIndex + 2 * 8], sA[lIndex + 2 * 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (2 * 8 + 2)], sG[lIndex + (2 * 8 + 2)], sB[lIndex + (2 * 8 + 2)], sA[lIndex + (2 * 8 + 2)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip3.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices.xy >> 2, gIndices.z);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 3)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x3f) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort2(1));
+        bool2 atEdge = (gIndices.xy >> 2) == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 4], sG[lIndex + 4], sB[lIndex + 4], sA[lIndex + 4]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + 4 * 8], sG[lIndex + 4 * 8], sB[lIndex + 4 * 8], sA[lIndex + 4 * 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (4 * 8 + 4)], sG[lIndex + (4 * 8 + 4)], sB[lIndex + (4 * 8 + 4)], sA[lIndex + (4 * 8 + 4)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip4.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices.xy >> 3, gIndices.z);
+    }
+}
+
+kernel void generateCubeMipmaps(uint lIndex [[thread_index_in_threadgroup]],
+                                ushort3 gIndices [[thread_position_in_grid]],
+                                texturecube<float> srcTexture [[texture(0)]],
+                                texturecube<float, access::write> dstMip1 [[texture(1)]],
+                                texturecube<float, access::write> dstMip2 [[texture(2)]],
+                                texturecube<float, access::write> dstMip3 [[texture(3)]],
+                                texturecube<float, access::write> dstMip4 [[texture(4)]],
+                                constant GenMipParams &options [[buffer(0)]])
+{
+    uint firstMipLevel = options.srcLevel + 1;
+    ushort2 mip1Size =
+        ushort2(srcTexture.get_width(firstMipLevel), srcTexture.get_height(firstMipLevel));
+    bool validThread = gIndices.x < mip1Size.x && gIndices.y < mip1Size.y;
+
+    constexpr sampler textureSampler(mag_filter::linear, min_filter::linear, mip_filter::linear);
+
+
+    float4 mip1Texel;
+    if (validThread)
+    {
+        float2 texCoords = (float2(gIndices.xy) + float2(0.5, 0.5)) / float2(mip1Size);
+        mip1Texel = srcTexture.sample(textureSampler, cubeTexcoords(texCoords, int(gIndices.z)),
+                                      level(options.srcLevel));
+
+
+        dstMip1.write((options.sRGB ? sRGBtoLinear(mip1Texel) : mip1Texel), gIndices.xy, gIndices.z);
+    }
+    else
+    {
+
+        lIndex = 0xffffffff;
+    }
+
+    if (options.numMipLevelsToGen == 1)
+    {
+        return;
+    }
+
+
+    threadgroup float sR[(8 * 8)];
+    threadgroup float sG[(8 * 8)];
+    threadgroup float sB[(8 * 8)];
+    threadgroup float sA[(8 * 8)];
+
+    generateCubeOr2DArray2ndAndMoreMipmaps(lIndex, gIndices, srcTexture, dstMip2, dstMip3, dstMip4,
+                                           mip1Size, mip1Texel, sR, sG, sB, sA, options);
+}
+
+kernel void generate2DArrayMipmaps(uint lIndex [[thread_index_in_threadgroup]],
+                                   ushort3 gIndices [[thread_position_in_grid]],
+                                   texture2d_array<float> srcTexture [[texture(0)]],
+                                   texture2d_array<float, access::write> dstMip1 [[texture(1)]],
+                                   texture2d_array<float, access::write> dstMip2 [[texture(2)]],
+                                   texture2d_array<float, access::write> dstMip3 [[texture(3)]],
+                                   texture2d_array<float, access::write> dstMip4 [[texture(4)]],
+                                   constant GenMipParams &options [[buffer(0)]])
+{
+    uint firstMipLevel = options.srcLevel + 1;
+    ushort2 mip1Size =
+        ushort2(srcTexture.get_width(firstMipLevel), srcTexture.get_height(firstMipLevel));
+    bool validThread = gIndices.x < mip1Size.x && gIndices.y < mip1Size.y;
+
+    constexpr sampler textureSampler(mag_filter::linear, min_filter::linear, mip_filter::linear);
+
+
+    float4 mip1Texel;
+    if (validThread)
+    {
+        float2 texCoords = (float2(gIndices.xy) + float2(0.5, 0.5)) / float2(mip1Size);
+        mip1Texel =
+            srcTexture.sample(textureSampler, texCoords, gIndices.z, level(options.srcLevel));
+
+
+        dstMip1.write((options.sRGB ? sRGBtoLinear(mip1Texel) : mip1Texel), gIndices.xy, gIndices.z);
+    }
+    else
+    {
+
+        lIndex = 0xffffffff;
+    }
+
+    if (options.numMipLevelsToGen == 1)
+    {
+        return;
+    }
+
+
+    threadgroup float sR[(8 * 8)];
+    threadgroup float sG[(8 * 8)];
+    threadgroup float sB[(8 * 8)];
+    threadgroup float sA[(8 * 8)];
+
+    generateCubeOr2DArray2ndAndMoreMipmaps(lIndex, gIndices, srcTexture, dstMip2, dstMip3, dstMip4,
+                                           mip1Size, mip1Texel, sR, sG, sB, sA, options);
+}
+# 5 "temp_master_source.metal" 2
+# 1 "./copy_buffer.metal" 1
+# 12 "./copy_buffer.metal"
+#include <metal_pack>
+
+
+# 1 "./format_autogen.h" 1
+
+
+
+namespace rx
+{
+namespace mtl_shader
+{
+
+namespace FormatID
+{
+enum
+{
+    NONE,
+    D16_UNORM,
+    D24_UNORM_S8_UINT,
+    D24_UNORM_X8_UINT,
+    D32_FLOAT,
+    D32_FLOAT_S8X24_UINT,
+    D32_UNORM,
+    S8_UINT,
+    A16_FLOAT,
+    A1R5G5B5_UNORM,
+    A2R10G10B10_SINT_VERTEX,
+    A2R10G10B10_SNORM_VERTEX,
+    A2R10G10B10_SSCALED_VERTEX,
+    A2R10G10B10_UINT_VERTEX,
+    A2R10G10B10_UNORM_VERTEX,
+    A2R10G10B10_USCALED_VERTEX,
+    A32_FLOAT,
+    A8_UNORM,
+    ASTC_10x10_SRGB_BLOCK,
+    ASTC_10x10_UNORM_BLOCK,
+    ASTC_10x5_SRGB_BLOCK,
+    ASTC_10x5_UNORM_BLOCK,
+    ASTC_10x6_SRGB_BLOCK,
+    ASTC_10x6_UNORM_BLOCK,
+    ASTC_10x8_SRGB_BLOCK,
+    ASTC_10x8_UNORM_BLOCK,
+    ASTC_12x10_SRGB_BLOCK,
+    ASTC_12x10_UNORM_BLOCK,
+    ASTC_12x12_SRGB_BLOCK,
+    ASTC_12x12_UNORM_BLOCK,
+    ASTC_3x3x3_UNORM_BLOCK,
+    ASTC_3x3x3_UNORM_SRGB_BLOCK,
+    ASTC_4x3x3_UNORM_BLOCK,
+    ASTC_4x3x3_UNORM_SRGB_BLOCK,
+    ASTC_4x4_SRGB_BLOCK,
+    ASTC_4x4_UNORM_BLOCK,
+    ASTC_4x4x3_UNORM_BLOCK,
+    ASTC_4x4x3_UNORM_SRGB_BLOCK,
+    ASTC_4x4x4_UNORM_BLOCK,
+    ASTC_4x4x4_UNORM_SRGB_BLOCK,
+    ASTC_5x4_SRGB_BLOCK,
+    ASTC_5x4_UNORM_BLOCK,
+    ASTC_5x4x4_UNORM_BLOCK,
+    ASTC_5x4x4_UNORM_SRGB_BLOCK,
+    ASTC_5x5_SRGB_BLOCK,
+    ASTC_5x5_UNORM_BLOCK,
+    ASTC_5x5x4_UNORM_BLOCK,
+    ASTC_5x5x4_UNORM_SRGB_BLOCK,
+    ASTC_5x5x5_UNORM_BLOCK,
+    ASTC_5x5x5_UNORM_SRGB_BLOCK,
+    ASTC_6x5_SRGB_BLOCK,
+    ASTC_6x5_UNORM_BLOCK,
+    ASTC_6x5x5_UNORM_BLOCK,
+    ASTC_6x5x5_UNORM_SRGB_BLOCK,
+    ASTC_6x6_SRGB_BLOCK,
+    ASTC_6x6_UNORM_BLOCK,
+    ASTC_6x6x5_UNORM_BLOCK,
+    ASTC_6x6x5_UNORM_SRGB_BLOCK,
+    ASTC_6x6x6_UNORM_BLOCK,
+    ASTC_6x6x6_UNORM_SRGB_BLOCK,
+    ASTC_8x5_SRGB_BLOCK,
+    ASTC_8x5_UNORM_BLOCK,
+    ASTC_8x6_SRGB_BLOCK,
+    ASTC_8x6_UNORM_BLOCK,
+    ASTC_8x8_SRGB_BLOCK,
+    ASTC_8x8_UNORM_BLOCK,
+    B10G10R10A2_UNORM,
+    B4G4R4A4_UNORM,
+    B5G5R5A1_UNORM,
+    B5G6R5_UNORM,
+    B8G8R8A8_TYPELESS,
+    B8G8R8A8_TYPELESS_SRGB,
+    B8G8R8A8_UNORM,
+    B8G8R8A8_UNORM_SRGB,
+    B8G8R8X8_UNORM,
+    BC1_RGBA_UNORM_BLOCK,
+    BC1_RGBA_UNORM_SRGB_BLOCK,
+    BC1_RGB_UNORM_BLOCK,
+    BC1_RGB_UNORM_SRGB_BLOCK,
+    BC2_RGBA_UNORM_BLOCK,
+    BC2_RGBA_UNORM_SRGB_BLOCK,
+    BC3_RGBA_UNORM_BLOCK,
+    BC3_RGBA_UNORM_SRGB_BLOCK,
+    BC4_RED_SNORM_BLOCK,
+    BC4_RED_UNORM_BLOCK,
+    BC5_RG_SNORM_BLOCK,
+    BC5_RG_UNORM_BLOCK,
+    BC6H_RGB_SFLOAT_BLOCK,
+    BC6H_RGB_UFLOAT_BLOCK,
+    BC7_RGBA_UNORM_BLOCK,
+    BC7_RGBA_UNORM_SRGB_BLOCK,
+    EAC_R11G11_SNORM_BLOCK,
+    EAC_R11G11_UNORM_BLOCK,
+    EAC_R11_SNORM_BLOCK,
+    EAC_R11_UNORM_BLOCK,
+    ETC1_LOSSY_DECODE_R8G8B8_UNORM_BLOCK,
+    ETC1_R8G8B8_UNORM_BLOCK,
+    ETC2_R8G8B8A1_SRGB_BLOCK,
+    ETC2_R8G8B8A1_UNORM_BLOCK,
+    ETC2_R8G8B8A8_SRGB_BLOCK,
+    ETC2_R8G8B8A8_UNORM_BLOCK,
+    ETC2_R8G8B8_SRGB_BLOCK,
+    ETC2_R8G8B8_UNORM_BLOCK,
+    G8_B8R8_2PLANE_420_UNORM,
+    G8_B8_R8_3PLANE_420_UNORM,
+    L16A16_FLOAT,
+    L16_FLOAT,
+    L32A32_FLOAT,
+    L32_FLOAT,
+    L8A8_UNORM,
+    L8_UNORM,
+    PALETTE4_R4G4B4A4_UNORM,
+    PALETTE4_R5G5B5A1_UNORM,
+    PALETTE4_R5G6B5_UNORM,
+    PALETTE4_R8G8B8A8_UNORM,
+    PALETTE4_R8G8B8_UNORM,
+    PALETTE8_R4G4B4A4_UNORM,
+    PALETTE8_R5G5B5A1_UNORM,
+    PALETTE8_R5G6B5_UNORM,
+    PALETTE8_R8G8B8A8_UNORM,
+    PALETTE8_R8G8B8_UNORM,
+    PVRTC1_RGBA_2BPP_UNORM_BLOCK,
+    PVRTC1_RGBA_2BPP_UNORM_SRGB_BLOCK,
+    PVRTC1_RGBA_4BPP_UNORM_BLOCK,
+    PVRTC1_RGBA_4BPP_UNORM_SRGB_BLOCK,
+    PVRTC1_RGB_2BPP_UNORM_BLOCK,
+    PVRTC1_RGB_2BPP_UNORM_SRGB_BLOCK,
+    PVRTC1_RGB_4BPP_UNORM_BLOCK,
+    PVRTC1_RGB_4BPP_UNORM_SRGB_BLOCK,
+    R10G10B10A2_SINT,
+    R10G10B10A2_SNORM,
+    R10G10B10A2_SSCALED,
+    R10G10B10A2_UINT,
+    R10G10B10A2_UNORM,
+    R10G10B10A2_USCALED,
+    R10G10B10X2_UNORM,
+    R11G11B10_FLOAT,
+    R16G16B16A16_FLOAT,
+    R16G16B16A16_SINT,
+    R16G16B16A16_SNORM,
+    R16G16B16A16_SSCALED,
+    R16G16B16A16_UINT,
+    R16G16B16A16_UNORM,
+    R16G16B16A16_USCALED,
+    R16G16B16_FLOAT,
+    R16G16B16_SINT,
+    R16G16B16_SNORM,
+    R16G16B16_SSCALED,
+    R16G16B16_UINT,
+    R16G16B16_UNORM,
+    R16G16B16_USCALED,
+    R16G16_FLOAT,
+    R16G16_SINT,
+    R16G16_SNORM,
+    R16G16_SSCALED,
+    R16G16_UINT,
+    R16G16_UNORM,
+    R16G16_USCALED,
+    R16_FLOAT,
+    R16_SINT,
+    R16_SNORM,
+    R16_SSCALED,
+    R16_UINT,
+    R16_UNORM,
+    R16_USCALED,
+    R32G32B32A32_FIXED,
+    R32G32B32A32_FLOAT,
+    R32G32B32A32_SINT,
+    R32G32B32A32_SNORM,
+    R32G32B32A32_SSCALED,
+    R32G32B32A32_UINT,
+    R32G32B32A32_UNORM,
+    R32G32B32A32_USCALED,
+    R32G32B32_FIXED,
+    R32G32B32_FLOAT,
+    R32G32B32_SINT,
+    R32G32B32_SNORM,
+    R32G32B32_SSCALED,
+    R32G32B32_UINT,
+    R32G32B32_UNORM,
+    R32G32B32_USCALED,
+    R32G32_FIXED,
+    R32G32_FLOAT,
+    R32G32_SINT,
+    R32G32_SNORM,
+    R32G32_SSCALED,
+    R32G32_UINT,
+    R32G32_UNORM,
+    R32G32_USCALED,
+    R32_FIXED,
+    R32_FLOAT,
+    R32_SINT,
+    R32_SNORM,
+    R32_SSCALED,
+    R32_UINT,
+    R32_UNORM,
+    R32_USCALED,
+    R4G4B4A4_UNORM,
+    R5G5B5A1_UNORM,
+    R5G6B5_UNORM,
+    R8G8B8A8_SINT,
+    R8G8B8A8_SNORM,
+    R8G8B8A8_SSCALED,
+    R8G8B8A8_TYPELESS,
+    R8G8B8A8_TYPELESS_SRGB,
+    R8G8B8A8_UINT,
+    R8G8B8A8_UNORM,
+    R8G8B8A8_UNORM_SRGB,
+    R8G8B8A8_USCALED,
+    R8G8B8X8_UNORM,
+    R8G8B8_SINT,
+    R8G8B8_SNORM,
+    R8G8B8_SSCALED,
+    R8G8B8_UINT,
+    R8G8B8_UNORM,
+    R8G8B8_UNORM_SRGB,
+    R8G8B8_USCALED,
+    R8G8_SINT,
+    R8G8_SNORM,
+    R8G8_SSCALED,
+    R8G8_UINT,
+    R8G8_UNORM,
+    R8G8_UNORM_SRGB,
+    R8G8_USCALED,
+    R8_SINT,
+    R8_SNORM,
+    R8_SSCALED,
+    R8_UINT,
+    R8_UNORM,
+    R8_UNORM_SRGB,
+    R8_USCALED,
+    R9G9B9E5_SHAREDEXP,
+    X2R10G10B10_SINT_VERTEX,
+    X2R10G10B10_SNORM_VERTEX,
+    X2R10G10B10_SSCALED_VERTEX,
+    X2R10G10B10_UINT_VERTEX,
+    X2R10G10B10_UNORM_VERTEX,
+    X2R10G10B10_USCALED_VERTEX
+};
+
+}
+
+}
+}
+# 16 "./copy_buffer.metal" 2
+
+using namespace rx::mtl_shader;
+
+constant int kCopyFormatType [[function_constant(10)]];
+
+
+constant int kCopyTextureType [[function_constant(20)]];
+constant bool kCopyTextureType2D = kCopyTextureType == kTextureType2D;
+constant bool kCopyTextureType2DArray = kCopyTextureType == kTextureType2DArray;
+constant bool kCopyTextureType2DMS = kCopyTextureType == kTextureType2DMultisample;
+constant bool kCopyTextureTypeCube = kCopyTextureType == kTextureTypeCube;
+constant bool kCopyTextureType3D = kCopyTextureType == kTextureType3D;
+
+struct CopyPixelParams
+{
+    uint3 copySize;
+    uint3 textureOffset;
+
+    uint bufferStartOffset;
+    uint pixelSize;
+    uint bufferRowPitch;
+    uint bufferDepthPitch;
+};
+
+struct WritePixelParams
+{
+    uint2 copySize;
+    uint2 textureOffset;
+
+    uint bufferStartOffset;
+
+    uint pixelSize;
+    uint bufferRowPitch;
+
+    uint textureLevel;
+    uint textureLayer;
+
+    bool reverseTextureRowOrder;
+};
+# 120 "./copy_buffer.metal"
+template <typename T>
+static inline void textureWrite(ushort3 gIndices,
+                                constant CopyPixelParams &options,
+                                vec<T, 4> color,
+                                texture2d<T, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<T, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<T, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<T, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
+{
+    uint3 writeIndices = options.textureOffset + uint3(gIndices);
+    switch (kCopyTextureType)
+    {
+        case kTextureType2D:
+            dstTexture2d.write(color, writeIndices.xy);
+            break;
+        case kTextureType2DArray:
+            dstTexture2dArray.write(color, writeIndices.xy, writeIndices.z);
+            break;
+        case kTextureType3D:
+            dstTexture3d.write(color, writeIndices);
+            break;
+        case kTextureTypeCube:
+            dstTextureCube.write(color, writeIndices.xy, writeIndices.z);
+            break;
+    }
+}
+
+
+template <typename T>
+static inline vec<T, 4> textureRead(ushort2 gIndices,
+                                    constant WritePixelParams &options,
+                                    texture2d<T, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<T, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<T, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<T, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<T, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]])
+{
+    vec<T, 4> color;
+    uint2 coords = uint2(gIndices);
+    if (options.reverseTextureRowOrder)
+    {
+        coords.y = options.copySize.y - 1 - gIndices.y;
+    }
+    coords += options.textureOffset;
+    switch (kCopyTextureType)
+    {
+        case kTextureType2D:
+            color = srcTexture2d.read(coords.xy, options.textureLevel);
+            break;
+        case kTextureType2DArray:
+            color = srcTexture2dArray.read(coords.xy, options.textureLayer, options.textureLevel);
+            break;
+        case kTextureType2DMultisample:
+            color = resolveTextureMS(srcTexture2dMS, coords.xy);
+            break;
+        case kTextureType3D:
+            color = srcTexture3d.read(uint3(coords, options.textureLayer), options.textureLevel);
+            break;
+        case kTextureTypeCube:
+            color = srcTextureCube.read(coords.xy, options.textureLayer, options.textureLevel);
+            break;
+    }
+    return color;
+}
+# 215 "./copy_buffer.metal"
+static inline float4 readR5G6B5_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    ushort src = bytesToShort<ushort>(buffer, bufferOffset);
+
+    color.r = normalizedToFloat<5>(getShiftedData<5, 11>(src));
+    color.g = normalizedToFloat<6>(getShiftedData<6, 5>(src));
+    color.b = normalizedToFloat<5>(getShiftedData<5, 0>(src));
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR5G6B5_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    ushort dst = shiftData<5, 11>(floatToNormalized<5, ushort>(color.r)) |
+                 shiftData<6, 5>(floatToNormalized<6, ushort>(color.g)) |
+                 shiftData<5, 0>(floatToNormalized<5, ushort>(color.b));
+
+    shortToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR4G4B4A4_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    ushort src = bytesToShort<ushort>(buffer, bufferOffset);
+
+    color.r = normalizedToFloat<4>(getShiftedData<4, 12>(src));
+    color.g = normalizedToFloat<4>(getShiftedData<4, 8>(src));
+    color.b = normalizedToFloat<4>(getShiftedData<4, 4>(src));
+    color.a = normalizedToFloat<4>(getShiftedData<4, 0>(src));
+    return color;
+}
+static inline void writeR4G4B4A4_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    ushort dst = shiftData<4, 12>(floatToNormalized<4, ushort>(color.r)) |
+                 shiftData<4, 8>(floatToNormalized<4, ushort>(color.g)) |
+                 shiftData<4, 4>(floatToNormalized<4, ushort>(color.b)) |
+                 shiftData<4, 0>(floatToNormalized<4, ushort>(color.a));
+    ;
+
+    shortToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR5G5B5A1_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    ushort src = bytesToShort<ushort>(buffer, bufferOffset);
+
+    color.r = normalizedToFloat<5>(getShiftedData<5, 11>(src));
+    color.g = normalizedToFloat<5>(getShiftedData<5, 6>(src));
+    color.b = normalizedToFloat<5>(getShiftedData<5, 1>(src));
+    color.a = normalizedToFloat<1>(getShiftedData<1, 0>(src));
+    return color;
+}
+static inline void writeR5G5B5A1_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    ushort dst = shiftData<5, 11>(floatToNormalized<5, ushort>(color.r)) |
+                 shiftData<5, 6>(floatToNormalized<5, ushort>(color.g)) |
+                 shiftData<5, 1>(floatToNormalized<5, ushort>(color.b)) |
+                 shiftData<1, 0>(floatToNormalized<1, ushort>(color.a));
+    ;
+
+    shortToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline int4 readR10G10B10A2_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    int src = bytesToInt<int>(buffer, bufferOffset);
+
+    constexpr int3 rgbSignMask(0x200);
+    constexpr int3 negativeMask(0xfffffc00);
+    constexpr int alphaSignMask = 0x2;
+    constexpr int alphaNegMask = 0xfffffffc;
+
+    color.r = getShiftedData<10, 0>(src);
+    color.g = getShiftedData<10, 10>(src);
+    color.b = getShiftedData<10, 20>(src);
+
+    int3 isRgbNegative = (color.rgb & rgbSignMask) >> 9;
+    color.rgb = (isRgbNegative * negativeMask) | color.rgb;
+
+    color.a = getShiftedData<2, 30>(src);
+    int isAlphaNegative = color.a & alphaSignMask >> 1;
+    color.a = (isAlphaNegative * alphaNegMask) | color.a;
+    return color;
+}
+
+static inline uint4 readR10G10B10A2_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    uint src = bytesToInt<uint>(buffer, bufferOffset);
+
+    color.r = getShiftedData<10, 0>(src);
+    color.g = getShiftedData<10, 10>(src);
+    color.b = getShiftedData<10, 20>(src);
+    color.a = getShiftedData<2, 30>(src);
+    return color;
+}
+
+
+static inline float4 readR8G8B8A8(uint bufferOffset, constant uchar *buffer, bool isSRGB)
+{
+    float4 color;
+    uint src = bytesToInt<uint>(buffer, bufferOffset);
+
+    if (isSRGB)
+    {
+        color = unpack_unorm4x8_srgb_to_float(src);
+    }
+    else
+    {
+        color = unpack_unorm4x8_to_float(src);
+    }
+    return color;
+}
+static inline void writeR8G8B8A8(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer, bool isSRGB)
+{
+    uint dst;
+
+    if (isSRGB)
+    {
+        dst = pack_float_to_srgb_unorm4x8(color);
+    }
+    else
+    {
+        dst = pack_float_to_unorm4x8(color);
+    }
+
+    intToBytes(dst, bufferOffset, buffer);
+}
+
+static inline float4 readR8G8B8(uint bufferOffset, constant uchar *buffer, bool isSRGB)
+{
+    float4 color;
+    color.r = normalizedToFloat<uchar>(buffer[bufferOffset]);
+    color.g = normalizedToFloat<uchar>(buffer[bufferOffset + 1]);
+    color.b = normalizedToFloat<uchar>(buffer[bufferOffset + 2]);
+    color.a = 1.0;
+
+    if (isSRGB)
+    {
+        color = sRGBtoLinear(color);
+    }
+    return color;
+}
+static inline void writeR8G8B8(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer, bool isSRGB)
+{
+    color.a = 1.0;
+    uint dst;
+
+    if (isSRGB)
+    {
+        dst = pack_float_to_srgb_unorm4x8(color);
+    }
+    else
+    {
+        dst = pack_float_to_unorm4x8(color);
+    }
+    int24bitToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR8G8B8A8_SNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    uint src = bytesToInt<uint>(buffer, bufferOffset);
+
+    color = unpack_snorm4x8_to_float(src);
+
+    return color;
+}
+static inline void writeR8G8B8A8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    uint dst = pack_float_to_snorm4x8(color);
+
+    intToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR8G8B8_SNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<7, char>(buffer[bufferOffset]);
+    color.g = normalizedToFloat<7, char>(buffer[bufferOffset + 1]);
+    color.b = normalizedToFloat<7, char>(buffer[bufferOffset + 2]);
+    color.a = 1.0;
+
+    return color;
+}
+static inline void writeR8G8B8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    uint dst = pack_float_to_snorm4x8(color);
+
+    int24bitToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR8G8B8A8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8A8(bufferOffset, buffer, false);
+}
+static inline void writeR8G8B8A8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, false);
+}
+
+static inline float4 readR8G8B8A8_UNORM_SRGB(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8A8(bufferOffset, buffer, true);
+}
+static inline void writeR8G8B8A8_UNORM_SRGB(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, true);
+}
+
+
+static inline float4 readB8G8R8A8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8A8(bufferOffset, buffer, false).bgra;
+}
+static inline void writeB8G8R8A8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    color.rgba = color.bgra;
+    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, false);
+}
+
+static inline float4 readB8G8R8A8_UNORM_SRGB(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8A8(bufferOffset, buffer, true).bgra;
+}
+static inline void writeB8G8R8A8_UNORM_SRGB(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    color.rgba = color.bgra;
+    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, true);
+}
+
+
+static inline float4 readR8G8B8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8(bufferOffset, buffer, false);
+}
+static inline void writeR8G8B8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    return writeR8G8B8(gIndices, options, bufferOffset, color, buffer, false);
+}
+
+static inline float4 readR8G8B8_UNORM_SRGB(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8(bufferOffset, buffer, true);
+}
+static inline void writeR8G8B8_UNORM_SRGB(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    return writeR8G8B8(gIndices, options, bufferOffset, color, buffer, true);
+}
+
+
+static inline float4 readL8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = float3(normalizedToFloat<uchar>(buffer[bufferOffset]));
+    color.a = 1.0;
+    return color;
+}
+static inline void writeL8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
+}
+
+
+static inline void writeA8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.a);
+}
+
+
+static inline float4 readL8A8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = float3(normalizedToFloat<uchar>(buffer[bufferOffset]));
+    color.a = normalizedToFloat<uchar>(buffer[bufferOffset + 1]);
+    return color;
+}
+static inline void writeL8A8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
+    buffer[bufferOffset + 1] = floatToNormalized<uchar>(color.a);
+}
+
+
+static inline float4 readR8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<uchar>(buffer[bufferOffset]);
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
+}
+
+static inline float4 readR8_SNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<7, char>(buffer[bufferOffset]);
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = as_type<uchar>(floatToNormalized<7, char>(color.r));
+}
+
+
+static inline int4 readR8_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = as_type<char>(buffer[bufferOffset]);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR8_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+}
+
+
+static inline uint4 readR8_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = as_type<uchar>(buffer[bufferOffset]);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR8_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+}
+
+
+static inline float4 readR8G8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<uchar>(buffer[bufferOffset]);
+    color.g = normalizedToFloat<uchar>(buffer[bufferOffset + 1]);
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR8G8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
+    buffer[bufferOffset + 1] = floatToNormalized<uchar>(color.g);
+}
+
+static inline float4 readR8G8_SNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<7, char>(buffer[bufferOffset]);
+    color.g = normalizedToFloat<7, char>(buffer[bufferOffset + 1]);
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR8G8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = as_type<uchar>(floatToNormalized<7, char>(color.r));
+    buffer[bufferOffset + 1] = as_type<uchar>(floatToNormalized<7, char>(color.g));
+}
+
+
+static inline int4 readR8G8_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = as_type<char>(buffer[bufferOffset]);
+    color.g = as_type<char>(buffer[bufferOffset + 1]);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR8G8_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
+}
+
+
+static inline uint4 readR8G8_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = as_type<uchar>(buffer[bufferOffset]);
+    color.g = as_type<uchar>(buffer[bufferOffset + 1]);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR8G8_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
+}
+
+
+static inline int4 readR8G8B8_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = as_type<char>(buffer[bufferOffset]);
+    color.g = as_type<char>(buffer[bufferOffset + 1]);
+    color.b = as_type<char>(buffer[bufferOffset + 2]);
+    color.a = 1;
+    return color;
+}
+
+
+static inline uint4 readR8G8B8_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = as_type<uchar>(buffer[bufferOffset]);
+    color.g = as_type<uchar>(buffer[bufferOffset + 1]);
+    color.b = as_type<uchar>(buffer[bufferOffset + 2]);
+    color.a = 1;
+    return color;
+}
+
+
+static inline int4 readR8G8B8A8_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = as_type<char>(buffer[bufferOffset]);
+    color.g = as_type<char>(buffer[bufferOffset + 1]);
+    color.b = as_type<char>(buffer[bufferOffset + 2]);
+    color.a = as_type<char>(buffer[bufferOffset + 3]);
+    return color;
+}
+static inline void writeR8G8B8A8_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
+    buffer[bufferOffset + 2] = static_cast<uchar>(color.b);
+    buffer[bufferOffset + 3] = static_cast<uchar>(color.a);
+}
+
+
+static inline uint4 readR8G8B8A8_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = as_type<uchar>(buffer[bufferOffset]);
+    color.g = as_type<uchar>(buffer[bufferOffset + 1]);
+    color.b = as_type<uchar>(buffer[bufferOffset + 2]);
+    color.a = as_type<uchar>(buffer[bufferOffset + 3]);
+    return color;
+}
+static inline void writeR8G8B8A8_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
+    buffer[bufferOffset + 2] = static_cast<uchar>(color.b);
+    buffer[bufferOffset + 3] = static_cast<uchar>(color.a);
+}
+
+
+static inline float4 readR16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+}
+
+template <typename ShortType>
+static inline float4 readR16_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline int4 readR16_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToShort<short>(buffer, bufferOffset);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR16_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<short>(color.r), bufferOffset, buffer);
+}
+
+
+static inline uint4 readR16_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToShort<ushort>(buffer, bufferOffset);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR16_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<ushort>(color.r), bufferOffset, buffer);
+}
+
+
+static inline float4 readA16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.a = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.rgb = 0.0;
+    return color;
+}
+static inline void writeA16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.a)), bufferOffset, buffer);
+}
+
+
+static inline float4 readL16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.a = 1.0;
+    return color;
+}
+static inline void writeL16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+}
+
+
+static inline float4 readL16A16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.a = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
+    return color;
+}
+static inline void writeL16A16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.a)), bufferOffset + 2, buffer);
+}
+
+
+static inline float4 readR16G16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.g = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR16G16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.g)), bufferOffset + 2, buffer);
+}
+
+
+template <typename ShortType>
+static inline float4 readR16G16_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 2));
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline int4 readR16G16_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToShort<short>(buffer, bufferOffset);
+    color.g = bytesToShort<short>(buffer, bufferOffset + 2);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR16G16_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<short>(color.r), bufferOffset, buffer);
+    shortToBytes(static_cast<short>(color.g), bufferOffset + 2, buffer);
+}
+
+
+static inline uint4 readR16G16_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToShort<ushort>(buffer, bufferOffset);
+    color.g = bytesToShort<ushort>(buffer, bufferOffset + 2);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR16G16_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<ushort>(color.r), bufferOffset, buffer);
+    shortToBytes(static_cast<ushort>(color.g), bufferOffset + 2, buffer);
+}
+
+
+static inline float4 readR16G16B16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.g = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
+    color.b = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 4));
+    color.a = 1.0;
+    return color;
+}
+
+
+template <typename ShortType>
+static inline float4 readR16G16B16_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 2));
+    color.b = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 4));
+    color.a = 1.0;
+    return color;
+}
+
+
+
+static inline int4 readR16G16B16_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToShort<short>(buffer, bufferOffset);
+    color.g = bytesToShort<short>(buffer, bufferOffset + 2);
+    color.b = bytesToShort<short>(buffer, bufferOffset + 4);
+    color.a = 1;
+    return color;
+}
+
+
+static inline uint4 readR16G16B16_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToShort<ushort>(buffer, bufferOffset);
+    color.g = bytesToShort<ushort>(buffer, bufferOffset + 2);
+    color.b = bytesToShort<ushort>(buffer, bufferOffset + 4);
+    color.a = 1;
+    return color;
+}
+
+
+static inline float4 readR16G16B16A16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.g = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
+    color.b = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 4));
+    color.a = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 6));
+    return color;
+}
+static inline void writeR16G16B16A16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.g)), bufferOffset + 2, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.b)), bufferOffset + 4, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.a)), bufferOffset + 6, buffer);
+}
+
+
+template <typename ShortType>
+static inline float4 readR16G16B16A16_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 2));
+    color.b = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 4));
+    color.a = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 6));
+    return color;
+}
+
+
+
+
+static inline int4 readR16G16B16A16_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToShort<short>(buffer, bufferOffset);
+    color.g = bytesToShort<short>(buffer, bufferOffset + 2);
+    color.b = bytesToShort<short>(buffer, bufferOffset + 4);
+    color.a = bytesToShort<short>(buffer, bufferOffset + 6);
+    return color;
+}
+static inline void writeR16G16B16A16_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<short>(color.r), bufferOffset, buffer);
+    shortToBytes(static_cast<short>(color.g), bufferOffset + 2, buffer);
+    shortToBytes(static_cast<short>(color.b), bufferOffset + 4, buffer);
+    shortToBytes(static_cast<short>(color.a), bufferOffset + 6, buffer);
+}
+
+
+static inline uint4 readR16G16B16A16_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToShort<ushort>(buffer, bufferOffset);
+    color.g = bytesToShort<ushort>(buffer, bufferOffset + 2);
+    color.b = bytesToShort<ushort>(buffer, bufferOffset + 4);
+    color.a = bytesToShort<ushort>(buffer, bufferOffset + 6);
+    return color;
+}
+static inline void writeR16G16B16A16_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<ushort>(color.r), bufferOffset, buffer);
+    shortToBytes(static_cast<ushort>(color.g), bufferOffset + 2, buffer);
+    shortToBytes(static_cast<ushort>(color.b), bufferOffset + 4, buffer);
+    shortToBytes(static_cast<ushort>(color.a), bufferOffset + 6, buffer);
+}
+
+
+static inline float4 readR32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+}
+
+
+template <typename IntType>
+static inline float4 readR32_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline float4 readA32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.a = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.rgb = 0.0;
+    return color;
+}
+static inline void writeA32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.a), bufferOffset, buffer);
+}
+
+
+static inline float4 readL32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.a = 1.0;
+    return color;
+}
+static inline void writeL32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+}
+
+
+static inline int4 readR32_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToInt<int>(buffer, bufferOffset);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR32_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+}
+
+
+static inline float4 readR32_FIXED(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    constexpr float kDivisor = 1.0f / (1 << 16);
+    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+static inline uint4 readR32_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToInt<uint>(buffer, bufferOffset);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR32_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+}
+
+
+static inline float4 readL32A32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.a = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
+    return color;
+}
+static inline void writeL32A32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+    intToBytes(as_type<uint>(color.a), bufferOffset + 4, buffer);
+}
+
+
+static inline float4 readR32G32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.g = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR32G32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+    intToBytes(as_type<uint>(color.g), bufferOffset + 4, buffer);
+}
+
+
+template <typename IntType>
+static inline float4 readR32G32_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 4));
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline int4 readR32G32_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToInt<int>(buffer, bufferOffset);
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR32G32_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+    intToBytes(color.g, bufferOffset + 4, buffer);
+}
+
+
+static inline float4 readR32G32_FIXED(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    constexpr float kDivisor = 1.0f / (1 << 16);
+    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4) * kDivisor;
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+static inline uint4 readR32G32_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToInt<uint>(buffer, bufferOffset);
+    color.g = bytesToInt<uint>(buffer, bufferOffset + 4);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR32G32_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+    intToBytes(color.g, bufferOffset + 4, buffer);
+}
+
+
+static inline float4 readR32G32B32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.g = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
+    color.b = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 8));
+    color.a = 1.0;
+    return color;
+}
+
+
+template <typename IntType>
+static inline float4 readR32G32B32_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 4));
+    color.b = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 8));
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline int4 readR32G32B32_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToInt<int>(buffer, bufferOffset);
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4);
+    color.b = bytesToInt<int>(buffer, bufferOffset + 8);
+    color.a = 1;
+    return color;
+}
+
+
+static inline float4 readR32G32B32_FIXED(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    constexpr float kDivisor = 1.0f / (1 << 16);
+    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4) * kDivisor;
+    color.b = bytesToInt<int>(buffer, bufferOffset + 8) * kDivisor;
+    color.a = 1.0;
+    return color;
+}
+
+
+static inline uint4 readR32G32B32_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToInt<uint>(buffer, bufferOffset);
+    color.g = bytesToInt<uint>(buffer, bufferOffset + 4);
+    color.b = bytesToInt<uint>(buffer, bufferOffset + 8);
+    color.a = 1;
+    return color;
+}
+
+
+static inline float4 readR32G32B32A32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.g = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
+    color.b = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 8));
+    color.a = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 12));
+    return color;
+}
+static inline void writeR32G32B32A32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+    intToBytes(as_type<uint>(color.g), bufferOffset + 4, buffer);
+    intToBytes(as_type<uint>(color.b), bufferOffset + 8, buffer);
+    intToBytes(as_type<uint>(color.a), bufferOffset + 12, buffer);
+}
+
+
+template <typename IntType>
+static inline float4 readR32G32B32A32_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 4));
+    color.b = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 8));
+    color.a = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 12));
+    return color;
+}
+
+
+
+
+static inline int4 readR32G32B32A32_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToInt<int>(buffer, bufferOffset);
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4);
+    color.b = bytesToInt<int>(buffer, bufferOffset + 8);
+    color.a = bytesToInt<int>(buffer, bufferOffset + 12);
+    return color;
+}
+static inline void writeR32G32B32A32_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+    intToBytes(color.g, bufferOffset + 4, buffer);
+    intToBytes(color.b, bufferOffset + 8, buffer);
+    intToBytes(color.a, bufferOffset + 12, buffer);
+}
+
+static inline float4 readR32G32B32A32_FIXED(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    constexpr float kDivisor = 1.0f / (1 << 16);
+    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4) * kDivisor;
+    color.b = bytesToInt<int>(buffer, bufferOffset + 8) * kDivisor;
+    color.a = bytesToInt<int>(buffer, bufferOffset + 12) * kDivisor;
+    return color;
+}
+
+
+static inline uint4 readR32G32B32A32_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToInt<uint>(buffer, bufferOffset);
+    color.g = bytesToInt<uint>(buffer, bufferOffset + 4);
+    color.b = bytesToInt<uint>(buffer, bufferOffset + 8);
+    color.a = bytesToInt<uint>(buffer, bufferOffset + 12);
+    return color;
+}
+static inline void writeR32G32B32A32_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+    intToBytes(color.g, bufferOffset + 4, buffer);
+    intToBytes(color.b, bufferOffset + 8, buffer);
+    intToBytes(color.a, bufferOffset + 12, buffer);
+}
+# 1292 "./copy_buffer.metal"
+static inline int4 readR8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8_SINT(bufferOffset, buffer); } static inline uint4 readR8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8_UINT(bufferOffset, buffer); } static inline int4 readR8G8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8_SINT(bufferOffset, buffer); } static inline uint4 readR8G8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8_UINT(bufferOffset, buffer); } static inline int4 readR8G8B8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8_SINT(bufferOffset, buffer); } static inline uint4 readR8G8B8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8_UINT(bufferOffset, buffer); } static inline int4 readR8G8B8A8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8A8_SINT(bufferOffset, buffer); } static inline uint4 readR8G8B8A8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8A8_UINT(bufferOffset, buffer); }
+static inline int4 readR16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16_SINT(bufferOffset, buffer); } static inline uint4 readR16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16_UINT(bufferOffset, buffer); } static inline int4 readR16G16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16_SINT(bufferOffset, buffer); } static inline uint4 readR16G16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16_UINT(bufferOffset, buffer); } static inline int4 readR16G16B16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16_SINT(bufferOffset, buffer); } static inline uint4 readR16G16B16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16_UINT(bufferOffset, buffer); } static inline int4 readR16G16B16A16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16A16_SINT(bufferOffset, buffer); } static inline uint4 readR16G16B16A16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16A16_UINT(bufferOffset, buffer); }
+static inline int4 readR32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32_SINT(bufferOffset, buffer); } static inline uint4 readR32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32_UINT(bufferOffset, buffer); } static inline int4 readR32G32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32_SINT(bufferOffset, buffer); } static inline uint4 readR32G32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32_UINT(bufferOffset, buffer); } static inline int4 readR32G32B32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32_SINT(bufferOffset, buffer); } static inline uint4 readR32G32B32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32_UINT(bufferOffset, buffer); } static inline int4 readR32G32B32A32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32A32_SINT(bufferOffset, buffer); } static inline uint4 readR32G32B32A32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32A32_UINT(bufferOffset, buffer); }
+
+static inline int4 readR10G10B10A2_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR10G10B10A2_SINT(bufferOffset, buffer); } static inline uint4 readR10G10B10A2_USCALED(uint bufferOffset, constant uchar *buffer) { return readR10G10B10A2_UINT(bufferOffset, buffer); }
+
+
+kernel void readFromBufferToFloatTexture(ushort3 gIndices [[thread_position_in_grid]], constant CopyPixelParams &options[[buffer(0)]], constant uchar *buffer [[buffer(1)]], texture2d<float, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<float, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<float, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<float, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y || gIndices.z >= options.copySize.z) { return; }
+# 1336 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.z * options.bufferDepthPitch + gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R5G6B5_UNORM: { auto color = readR5G6B5_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_UNORM: { auto color = readR8G8B8A8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_UNORM_SRGB: { auto color = readR8G8B8A8_UNORM_SRGB(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_SNORM: { auto color = readR8G8B8A8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::B8G8R8A8_UNORM: { auto color = readB8G8R8A8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::B8G8R8A8_UNORM_SRGB: { auto color = readB8G8R8A8_UNORM_SRGB(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_UNORM: { auto color = readR8G8B8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_UNORM_SRGB: { auto color = readR8G8B8_UNORM_SRGB(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_SNORM: { auto color = readR8G8B8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L8_UNORM: { auto color = readL8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L8A8_UNORM: { auto color = readL8A8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R5G5B5A1_UNORM: { auto color = readR5G5B5A1_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R4G4B4A4_UNORM: { auto color = readR4G4B4A4_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8_UNORM: { auto color = readR8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8_SNORM: { auto color = readR8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_UNORM: { auto color = readR8G8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_SNORM: { auto color = readR8G8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16_FLOAT: { auto color = readR16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::A16_FLOAT: { auto color = readA16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L16_FLOAT: { auto color = readL16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L16A16_FLOAT: { auto color = readL16A16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16_FLOAT: { auto color = readR16G16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16_FLOAT: { auto color = readR16G16B16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16A16_FLOAT: { auto color = readR16G16B16A16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32_FLOAT: { auto color = readR32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::A32_FLOAT: { auto color = readA32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L32_FLOAT: { auto color = readL32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L32A32_FLOAT: { auto color = readL32A32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32_FLOAT: { auto color = readR32G32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32_FLOAT: { auto color = readR32G32B32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32A32_FLOAT: { auto color = readR32G32B32A32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break;
+    }
+
+
+}
+
+kernel void readFromBufferToIntTexture(ushort3 gIndices [[thread_position_in_grid]], constant CopyPixelParams &options[[buffer(0)]], constant uchar *buffer [[buffer(1)]], texture2d<int, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<int, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<int, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<int, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y || gIndices.z >= options.copySize.z) { return; }
+# 1364 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.z * options.bufferDepthPitch + gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_SINT: { auto color = readR8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_SINT: { auto color = readR8G8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_SINT: { auto color = readR8G8B8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_SINT: { auto color = readR8G8B8A8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16_SINT: { auto color = readR16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16_SINT: { auto color = readR16G16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16_SINT: { auto color = readR16G16B16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16A16_SINT: { auto color = readR16G16B16A16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32_SINT: { auto color = readR32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32_SINT: { auto color = readR32G32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32_SINT: { auto color = readR32G32B32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32A32_SINT: { auto color = readR32G32B32A32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break;
+    }
+
+
+}
+
+kernel void readFromBufferToUIntTexture(ushort3 gIndices [[thread_position_in_grid]], constant CopyPixelParams &options[[buffer(0)]], constant uchar *buffer [[buffer(1)]], texture2d<uint, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<uint, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<uint, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<uint, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y || gIndices.z >= options.copySize.z) { return; }
+# 1392 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.z * options.bufferDepthPitch + gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_UINT: { auto color = readR8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_UINT: { auto color = readR8G8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_UINT: { auto color = readR8G8B8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_UINT: { auto color = readR8G8B8A8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16_UINT: { auto color = readR16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16_UINT: { auto color = readR16G16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16_UINT: { auto color = readR16G16B16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16A16_UINT: { auto color = readR16G16B16A16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32_UINT: { auto color = readR32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32_UINT: { auto color = readR32G32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32_UINT: { auto color = readR32G32B32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32A32_UINT: { auto color = readR32G32B32A32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break;
+    }
+
+
+}
+
+
+kernel void writeFromFloatTextureToBuffer(ushort2 gIndices [[thread_position_in_grid]], constant WritePixelParams &options[[buffer(0)]], texture2d<float, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<float, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<float, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<float, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<float, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]], device uchar *buffer [[buffer(1)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y) { return; }
+# 1439 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R5G6B5_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR5G6B5_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_UNORM_SRGB: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_UNORM_SRGB(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::B8G8R8A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeB8G8R8A8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::B8G8R8A8_UNORM_SRGB: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeB8G8R8A8_UNORM_SRGB(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8_UNORM_SRGB: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8_UNORM_SRGB(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeA8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L8A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL8A8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R5G5B5A1_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR5G5B5A1_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R4G4B4A4_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR4G4B4A4_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::A16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeA16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L16A16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL16A16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16B16A16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16B16A16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::A32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeA32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L32A32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL32A32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32B32A32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32B32A32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break;
+    }
+
+
+}
+
+kernel void writeFromIntTextureToBuffer(ushort2 gIndices [[thread_position_in_grid]], constant WritePixelParams &options[[buffer(0)]], texture2d<int, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<int, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<int, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<int, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<int, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]], device uchar *buffer [[buffer(1)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y) { return; }
+# 1464 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16B16A16_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16B16A16_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32B32A32_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32B32A32_SINT(gIndices, options, bufferOffset, color, buffer); } break;
+    }
+
+
+}
+
+kernel void writeFromUIntTextureToBuffer(ushort2 gIndices [[thread_position_in_grid]], constant WritePixelParams &options[[buffer(0)]], texture2d<uint, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<uint, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<uint, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<uint, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<uint, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]], device uchar *buffer [[buffer(1)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y) { return; }
+# 1489 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16B16A16_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16B16A16_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32B32A32_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32B32A32_UINT(gIndices, options, bufferOffset, color, buffer); } break;
+    }
+
+
+}
+
+
+struct CopyVertexParams
+{
+    uint srcBufferStartOffset;
+    uint srcStride;
+    uint srcComponentBytes;
+    uint srcComponents;
+
+
+
+    uchar4 srcDefaultAlphaData;
+
+    uint dstBufferStartOffset;
+    uint dstStride;
+    uint dstComponents;
+
+    uint vertexCount;
+};
+# 1539 "./copy_buffer.metal"
+template <typename IntType>
+static inline void writeFloatVertex(constant CopyVertexParams &options,
+                                    uint idx,
+                                    vec<IntType, 4> data,
+                                    device uchar *dst)
+{
+    uint dstOffset = idx * options.dstStride + options.dstBufferStartOffset;
+
+    for (uint component = 0; component < options.dstComponents; ++component, dstOffset += 4)
+    {
+        floatToBytes(static_cast<float>(data[component]), dstOffset, dst);
+    }
+}
+
+template <>
+inline void writeFloatVertex(constant CopyVertexParams &options,
+                             uint idx,
+                             vec<float, 4> data,
+                             device uchar *dst)
+{
+    uint dstOffset = idx * options.dstStride + options.dstBufferStartOffset;
+
+    for (uint component = 0; component < options.dstComponents; ++component, dstOffset += 4)
+    {
+        floatToBytes(data[component], dstOffset, dst);
+    }
+}
+
+
+static inline void convertToFloatVertexFormat(uint index,
+                                              constant CopyVertexParams &options,
+                                              constant uchar *srcBuffer,
+                                              device uchar *dstBuffer)
+{
+# 1585 "./copy_buffer.metal"
+    uint bufferOffset = options.srcBufferStartOffset + options.srcStride * index;
+# 1594 "./copy_buffer.metal"
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_UNORM: { auto data = readR8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_SNORM: { auto data = readR8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_UINT: { auto data = readR8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_SINT: { auto data = readR8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_USCALED: { auto data = readR8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_SSCALED: { auto data = readR8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_UNORM: { auto data = readR8G8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_SNORM: { auto data = readR8G8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_UINT: { auto data = readR8G8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_SINT: { auto data = readR8G8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_USCALED: { auto data = readR8G8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_SSCALED: { auto data = readR8G8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_UNORM: { auto data = readR8G8B8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_SNORM: { auto data = readR8G8B8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_UINT: { auto data = readR8G8B8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_SINT: { auto data = readR8G8B8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_USCALED: { auto data = readR8G8B8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_SSCALED: { auto data = readR8G8B8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_UNORM: { auto data = readR8G8B8A8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_SNORM: { auto data = readR8G8B8A8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_UINT: { auto data = readR8G8B8A8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_SINT: { auto data = readR8G8B8A8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_USCALED: { auto data = readR8G8B8A8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_SSCALED: { auto data = readR8G8B8A8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_UNORM: { auto data = readR16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_SNORM: { auto data = readR16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_UINT: { auto data = readR16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_SINT: { auto data = readR16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_USCALED: { auto data = readR16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_SSCALED: { auto data = readR16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_UNORM: { auto data = readR16G16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_SNORM: { auto data = readR16G16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_UINT: { auto data = readR16G16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_SINT: { auto data = readR16G16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_USCALED: { auto data = readR16G16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_SSCALED: { auto data = readR16G16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_UNORM: { auto data = readR16G16B16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_SNORM: { auto data = readR16G16B16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_UINT: { auto data = readR16G16B16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_SINT: { auto data = readR16G16B16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_USCALED: { auto data = readR16G16B16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_SSCALED: { auto data = readR16G16B16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_UNORM: { auto data = readR16G16B16A16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_SNORM: { auto data = readR16G16B16A16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_UINT: { auto data = readR16G16B16A16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_SINT: { auto data = readR16G16B16A16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_USCALED: { auto data = readR16G16B16A16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_SSCALED: { auto data = readR16G16B16A16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_UNORM: { auto data = readR32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_SNORM: { auto data = readR32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_UINT: { auto data = readR32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_SINT: { auto data = readR32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_USCALED: { auto data = readR32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_SSCALED: { auto data = readR32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_UNORM: { auto data = readR32G32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_SNORM: { auto data = readR32G32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_UINT: { auto data = readR32G32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_SINT: { auto data = readR32G32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_USCALED: { auto data = readR32G32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_SSCALED: { auto data = readR32G32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_UNORM: { auto data = readR32G32B32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_SNORM: { auto data = readR32G32B32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_UINT: { auto data = readR32G32B32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_SINT: { auto data = readR32G32B32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_USCALED: { auto data = readR32G32B32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_SSCALED: { auto data = readR32G32B32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_UNORM: { auto data = readR32G32B32A32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_SNORM: { auto data = readR32G32B32A32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_UINT: { auto data = readR32G32B32A32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_SINT: { auto data = readR32G32B32A32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_USCALED: { auto data = readR32G32B32A32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_SSCALED: { auto data = readR32G32B32A32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_FLOAT: { auto data = readR16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_FLOAT: { auto data = readR16G16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_FLOAT: { auto data = readR16G16B16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_FLOAT: { auto data = readR16G16B16A16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_FLOAT: { auto data = readR32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_FLOAT: { auto data = readR32G32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_FLOAT: { auto data = readR32G32B32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_FLOAT: { auto data = readR32G32B32A32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_FIXED: { auto data = readR32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_FIXED: { auto data = readR32G32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_FIXED: { auto data = readR32G32B32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_FIXED: { auto data = readR32G32B32A32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_SINT: { auto data = readR10G10B10A2_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_UINT: { auto data = readR10G10B10A2_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_SSCALED: { auto data = readR10G10B10A2_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_USCALED: { auto data = readR10G10B10A2_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break;
+    }
+
+
+}
+
+
+kernel void convertToFloatVertexFormatCS(uint index [[thread_position_in_grid]],
+                                         constant CopyVertexParams &options [[buffer(0)]],
+                                         constant uchar *srcBuffer [[buffer(1)]],
+                                         device uchar *dstBuffer [[buffer(2)]])
+{
+    if (index >= options.vertexCount) { return; };
+    convertToFloatVertexFormat(index, options, srcBuffer, dstBuffer);
+}
+
+
+vertex void convertToFloatVertexFormatVS(uint index [[vertex_id]],
+                                         constant CopyVertexParams &options [[buffer(0)]],
+                                         constant uchar *srcBuffer [[buffer(1)]],
+                                         device uchar *dstBuffer [[buffer(2)]])
+{
+    convertToFloatVertexFormat(index, options, srcBuffer, dstBuffer);
+}
+
+
+static inline void expandVertexFormatComponents(uint index,
+                                                constant CopyVertexParams &options,
+                                                constant uchar *srcBuffer,
+                                                device uchar *dstBuffer)
+{
+    uint srcOffset = options.srcBufferStartOffset + options.srcStride * index;
+    uint dstOffset = options.dstBufferStartOffset + options.dstStride * index;
+
+    uint dstComponentsBeforeAlpha = min(options.dstComponents, 3u);
+    uint component;
+    for (component = 0; component < options.srcComponents; ++component,
+        srcOffset += options.srcComponentBytes, dstOffset += options.srcComponentBytes)
+    {
+        for (uint byte = 0; byte < options.srcComponentBytes; ++byte)
+        {
+            dstBuffer[dstOffset + byte] = srcBuffer[srcOffset + byte];
+        }
+    }
+
+    for (; component < dstComponentsBeforeAlpha;
+         ++component, dstOffset += options.srcComponentBytes)
+    {
+        for (uint byte = 0; byte < options.srcComponentBytes; ++byte)
+        {
+            dstBuffer[dstOffset + byte] = 0;
+        }
+    }
+
+    if (component < options.dstComponents)
+    {
+
+        for (uint byte = 0; byte < options.srcComponentBytes; ++byte)
+        {
+            dstBuffer[dstOffset + byte] = options.srcDefaultAlphaData[byte];
+        }
+    }
+}
+
+
+kernel void expandVertexFormatComponentsCS(uint index [[thread_position_in_grid]],
+                                           constant CopyVertexParams &options [[buffer(0)]],
+                                           constant uchar *srcBuffer [[buffer(1)]],
+                                           device uchar *dstBuffer [[buffer(2)]])
+{
+    if (index >= options.vertexCount) { return; };
+
+    expandVertexFormatComponents(index, options, srcBuffer, dstBuffer);
+}
+
+
+vertex void expandVertexFormatComponentsVS(uint index [[vertex_id]],
+                                           constant CopyVertexParams &options [[buffer(0)]],
+                                           constant uchar *srcBuffer [[buffer(1)]],
+                                           device uchar *dstBuffer [[buffer(2)]])
+{
+    expandVertexFormatComponents(index, options, srcBuffer, dstBuffer);
+}
+# 6 "temp_master_source.metal" 2
+# 1 "./visibility.metal" 1
+
+
+
+
+
+
+
+
+constant bool kCombineWithExistingResult [[function_constant(1000)]];
+
+
+
+struct CombineVisibilityResultOptions
+{
+
+    uint startOffset;
+
+    uint numOffsets;
+};
+
+kernel void combineVisibilityResult(uint idx [[thread_position_in_grid]],
+                                    constant CombineVisibilityResultOptions &options [[buffer(0)]],
+                                    constant ushort4 *renderpassVisibilityResult [[buffer(1)]],
+                                    device ushort4 *finalResults [[buffer(2)]])
+{
+    if (idx > 0)
+    {
+
+
+
+        return;
+    }
+    ushort4 finalResult16x4;
+
+    if (kCombineWithExistingResult)
+    {
+        finalResult16x4 = finalResults[0];
+    }
+    else
+    {
+        finalResult16x4 = ushort4(0, 0, 0, 0);
+    }
+
+    for (uint i = 0; i < options.numOffsets; ++i)
+    {
+        uint offset = options.startOffset + i;
+        ushort4 renderpassResult = renderpassVisibilityResult[offset];
+
+
+        finalResult16x4 = finalResult16x4 | renderpassResult;
+    }
+    finalResults[0] = finalResult16x4;
+}
+# 7 "temp_master_source.metal" 2
+# 1 "./rewrite_indices.metal" 1
+# 11 "./rewrite_indices.metal"
+# 1 "./rewrite_indices_shared.h" 1
+# 12 "./rewrite_indices.metal" 2
+using namespace metal;
+
+constant uint fixIndexBufferKey [[ function_constant(2000) ]];
+constant bool indexBufferIsUint16 = (((fixIndexBufferKey >> 0U) & 0x03U) == 2U);
+constant bool indexBufferIsUint32 = (((fixIndexBufferKey >> 0U) & 0x03U) == 3U);
+constant bool outIndexBufferIsUint16 = (((fixIndexBufferKey >> 2U) & 0x03U) == 2U);
+constant bool outIndexBufferIsUint32 = (((fixIndexBufferKey >> 2U) & 0x03U) == 3U);
+constant bool doPrimRestart = (fixIndexBufferKey & 0x00100U);
+constant uint fixIndexBufferMode = (fixIndexBufferKey >> 4U) & 0x0FU;
+
+
+static inline uint readIdx(
+                           const device ushort *indexBufferUint16,
+                           const device uint *indexBufferUint32,
+                           const uint restartIndex,
+                           const uint indexCount,
+                           uint idx,
+                           thread bool &foundRestart,
+                           thread uint &indexThatRestartedFirst
+                           )
+{
+    uint inIndex = idx;
+    if(inIndex < indexCount)
+    {
+        if(indexBufferIsUint16)
+        {
+            inIndex = indexBufferUint16[inIndex];
+        }
+        else if(indexBufferIsUint32)
+        {
+            inIndex = indexBufferUint32[inIndex];
+        }
+    }
+    else
+    {
+        foundRestart = true;
+        indexThatRestartedFirst = idx;
+    }
+    if(doPrimRestart && !foundRestart && inIndex == restartIndex)
+    {
+        foundRestart = true;
+        indexThatRestartedFirst = idx;
+    }
+    return inIndex;
+}
+
+static inline void outputPrimitive(
+                                   const device ushort *indexBufferUint16,
+                                   const device uint *indexBufferUint32,
+                                   device ushort *outIndexBufferUint16,
+                                   device uint *outIndexBufferUint32,
+                                   const uint restartIndex,
+                                   const uint indexCount,
+                                   thread uint &baseIndex,
+                                   uint onIndex,
+                                   thread uint &onOutIndex
+                                   )
+{
+    if(baseIndex > onIndex) return;
+    bool foundRestart = false;
+    uint indexThatRestartedFirst = 0;
+# 86 "./rewrite_indices.metal"
+    switch(fixIndexBufferMode)
+    {
+        case 0x00U:
+        {
+            auto tmpIndex = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+
+            ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex; } onOutIndex++; });
+        }
+        break;
+        case 0x01U:
+        {
+            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+            if((onIndex - baseIndex) & 1) return;
+
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+            }
+            else
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+            }
+        }
+        break;
+        case 0x03U:
+        {
+            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+            }
+            else
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+            }
+        }
+        break;
+        case 0x04U:
+        {
+            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex2 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 2, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+            if(((onIndex - baseIndex) % 3) != 0) return;
+
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+            }
+            else
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+            }
+        }
+        break;
+        case 0x05U:
+        {
+            uint isOdd = ((onIndex - baseIndex) & 1);
+            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0 + isOdd, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1 - isOdd, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex2 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 2, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+            }
+            else
+            {
+
+                if(isOdd)
+                {
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                }
+                else
+                {
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+                }
+            }
+
+            assert(onOutIndex <= (onIndex + 1) * 3);
+            assert(onOutIndex <= (indexCount - 2) * 3);
+        }
+        break;
+
+    }
+
+
+}
+
+kernel void fixIndexBuffer(
+                           const device ushort *indexBufferUint16 [[ buffer(0), function_constant(indexBufferIsUint16) ]],
+                           const device uint *indexBufferUint32 [[ buffer(0), function_constant(indexBufferIsUint32) ]],
+                           device ushort *outIndexBufferUint16 [[ buffer(1), function_constant(outIndexBufferIsUint16) ]],
+                           device uint *outIndexBufferUint32 [[ buffer(1), function_constant(outIndexBufferIsUint32) ]],
+                           constant uint &indexCount [[ buffer(2) ]],
+                           constant uint &primCount [[ buffer(3) ]],
+                           uint prim [[thread_position_in_grid]])
+{
+    constexpr uint restartIndex = 0xFFFFFFFF;
+    uint baseIndex = 0;
+    uint onIndex = onIndex;
+    uint onOutIndex = onOutIndex;
+    if(prim < primCount)
+    {
+        switch(fixIndexBufferMode)
+        {
+            case 0x00U:
+                onIndex = prim;
+                onOutIndex = prim;
+                break;
+            case 0x01U:
+                onIndex = prim * 2;
+                onOutIndex = prim * 2;
+                break;
+            case 0x03U:
+                onIndex = prim;
+                onOutIndex = prim * 2;
+                break;
+            case 0x04U:
+                onIndex = prim * 3;
+                onOutIndex = prim * 3;
+                break;
+            case 0x05U:
+                onIndex = prim;
+                onOutIndex = prim * 3;
+                break;
+        }
+        outputPrimitive(indexBufferUint16, indexBufferUint32, outIndexBufferUint16, outIndexBufferUint32, restartIndex, indexCount, baseIndex, onIndex, onOutIndex);
+    }
+}
+
+
+
+static inline void generatePrimitive(
+                                   device ushort *outIndexBufferUint16,
+                                   device uint *outIndexBufferUint32,
+                                   const uint firstVertex,
+                                   const uint indexCount,
+                                   thread uint &baseIndex,
+                                   uint onIndex,
+                                   uint primCount,
+                                   thread uint &onOutIndex
+                                   )
+{
+    if(baseIndex > onIndex) return;
+# 284 "./rewrite_indices.metal"
+    switch(fixIndexBufferMode)
+    {
+        case 0x00U:
+        {
+            ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = onIndex + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = onIndex + firstVertex; } onOutIndex++; });
+        }
+        break;
+        case 0x01U:
+        {
+            auto tmpIndex0 = onIndex + 0;
+            auto tmpIndex1 = onIndex + 1;
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0 + firstVertex; } onOutIndex++; });
+            }
+            else
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1 + firstVertex; } onOutIndex++; });
+            }
+        }
+        break;
+        case 0x02U:
+        {
+            auto tmpIndex0 = onIndex + 0;
+            auto tmpIndex1 = (onIndex + 1) % primCount;
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0 + firstVertex; } onOutIndex++; });
+            }
+            else
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1 + firstVertex; } onOutIndex++; });
+            }
+        }
+        break;
+        case 0x03U:
+        {
+            auto tmpIndex0 = onIndex + 0;
+            auto tmpIndex1 = onIndex + 1;
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0 + firstVertex; } onOutIndex++; });
+            }
+            else
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1 + firstVertex; } onOutIndex++; });
+            }
+        }
+        break;
+        case 0x04U:
+        {
+            auto tmpIndex0 = onIndex + 0;
+            auto tmpIndex1 = onIndex + 1;
+            auto tmpIndex2 = onIndex + 2;
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1 + firstVertex; } onOutIndex++; });
+            }
+            else
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2 + firstVertex; } onOutIndex++; });
+            }
+        }
+        break;
+        case 0x05U:
+        {
+            uint isOdd = ((onIndex - baseIndex) & 1);
+            auto tmpIndex0 = onIndex + 0 + isOdd;
+            auto tmpIndex1 = onIndex + 1 - isOdd;
+            auto tmpIndex2 = onIndex + 2;
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1 + firstVertex; } onOutIndex++; });
+            }
+            else
+            {
+                if(isOdd)
+                {
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1 + firstVertex; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2 + firstVertex; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0 + firstVertex; } onOutIndex++; });
+                }
+                else
+                {
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0 + firstVertex; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1 + firstVertex; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2 + firstVertex; } onOutIndex++; });
+                }
+            }
+
+            assert(onOutIndex <= (onIndex + 1) * 3);
+            assert(onOutIndex <= (indexCount - 2) * 3);
+            break;
+        }
+        case 0x06U:
+        {
+            auto tmpIndex0 = 0;
+            auto tmpIndex1 = onIndex + 1;
+            auto tmpIndex2 = onIndex + 2;
+
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1 + firstVertex; } onOutIndex++; });
+            }
+            else
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2 + firstVertex; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0 + firstVertex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0 + firstVertex; } onOutIndex++; });
+            }
+        }
+        break;
+
+    }
+
+}
+
+
+
+kernel void genIndexBuffer(
+                           device ushort *outIndexBufferUint16 [[ buffer(1), function_constant(outIndexBufferIsUint16) ]],
+                           device uint *outIndexBufferUint32 [[ buffer(1), function_constant(outIndexBufferIsUint32) ]],
+                           constant uint &indexCount [[ buffer(2) ]],
+                           constant uint &primCount [[ buffer(3) ]],
+                           constant uint &firstVertex [[ buffer(4) ]],
+                           uint prim [[thread_position_in_grid]])
+{
+    uint baseIndex = 0;
+    uint onIndex = onIndex;
+    uint onOutIndex = onOutIndex;
+    if(prim < primCount)
+    {
+        switch(fixIndexBufferMode)
+        {
+            case 0x00U:
+                onIndex = prim;
+                onOutIndex = prim;
+                break;
+            case 0x01U:
+                onIndex = prim * 2;
+                onOutIndex = prim * 2;
+                break;
+            case 0x03U:
+                onIndex = prim;
+                onOutIndex = prim * 2;
+                break;
+            case 0x02U:
+                onIndex = prim;
+                onOutIndex = prim * 2;
+                break;
+            case 0x04U:
+                onIndex = prim * 3;
+                onOutIndex = prim * 3;
+                break;
+            case 0x05U:
+                onIndex = prim;
+                onOutIndex = prim * 3;
+                break;
+            case 0x06U:
+                onIndex = prim;
+                onOutIndex = prim * 3;
+                break;
+        }
+        generatePrimitive(outIndexBufferUint16, outIndexBufferUint32, firstVertex, indexCount, baseIndex, onIndex, primCount, onOutIndex);
+    }
+}
+# 8 "temp_master_source.metal" 2
+
diff --git a/src/tests/gl_tests/WebGLCompatibilityTest.cpp b/src/tests/gl_tests/WebGLCompatibilityTest.cpp
index 5b2d7dac791592c54d1b0c91874e48ed321eb49a..5389f54ae05a7498c75ee7647746f0b2162f9d88 100644
--- a/src/tests/gl_tests/WebGLCompatibilityTest.cpp
+++ b/src/tests/gl_tests/WebGLCompatibilityTest.cpp
@@ -5426,7 +5426,7 @@ float g()
 float h()
 {
     vec4 value;
-    float value2
+    float value2;
     return value.x + value2;
 }
 
@@ -5438,6 +5438,131 @@ void main()
         gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
 })";
 
+    constexpr char kTooLargeGlobalMemoryOverflow[] =
+        R"(precision mediump float;
+
+// 16 MB / 16 bytes per vec4 = 1048576
+// Create 256 arrays so each is small, but the total overflows a 32-bit number
+vec4 array[1048576], array2[1048576], array3[1048576], array4[1048576], array5[1048576];
+vec4 array6[1048576], array7[1048576], array8[1048576], array9[1048576], array10[1048576];
+vec4 array11[1048576], array12[1048576], array13[1048576], array14[1048576], array15[1048576];
+vec4 array16[1048576], array17[1048576], array18[1048576], array19[1048576], array20[1048576];
+vec4 array21[1048576], array22[1048576], array23[1048576], array24[1048576], array25[1048576];
+vec4 array26[1048576], array27[1048576], array28[1048576], array29[1048576], array30[1048576];
+vec4 array31[1048576], array32[1048576], array33[1048576], array34[1048576], array35[1048576];
+vec4 array36[1048576], array37[1048576], array38[1048576], array39[1048576], array40[1048576];
+vec4 array41[1048576], array42[1048576], array43[1048576], array44[1048576], array45[1048576];
+vec4 array46[1048576], array47[1048576], array48[1048576], array49[1048576], array50[1048576];
+vec4 array51[1048576], array52[1048576], array53[1048576], array54[1048576], array55[1048576];
+vec4 array56[1048576], array57[1048576], array58[1048576], array59[1048576], array60[1048576];
+vec4 array61[1048576], array62[1048576], array63[1048576], array64[1048576], array65[1048576];
+vec4 array66[1048576], array67[1048576], array68[1048576], array69[1048576], array70[1048576];
+vec4 array71[1048576], array72[1048576], array73[1048576], array74[1048576], array75[1048576];
+vec4 array76[1048576], array77[1048576], array78[1048576], array79[1048576], array80[1048576];
+vec4 array81[1048576], array82[1048576], array83[1048576], array84[1048576], array85[1048576];
+vec4 array86[1048576], array87[1048576], array88[1048576], array89[1048576], array90[1048576];
+vec4 array91[1048576], array92[1048576], array93[1048576], array94[1048576], array95[1048576];
+vec4 array96[1048576], array97[1048576], array98[1048576], array99[1048576], array100[1048576];
+vec4 array101[1048576], array102[1048576], array103[1048576], array104[1048576], array105[1048576];
+vec4 array106[1048576], array107[1048576], array108[1048576], array109[1048576], array110[1048576];
+vec4 array111[1048576], array112[1048576], array113[1048576], array114[1048576], array115[1048576];
+vec4 array116[1048576], array117[1048576], array118[1048576], array119[1048576], array120[1048576];
+vec4 array121[1048576], array122[1048576], array123[1048576], array124[1048576], array125[1048576];
+vec4 array126[1048576], array127[1048576], array128[1048576], array129[1048576], array130[1048576];
+vec4 array131[1048576], array132[1048576], array133[1048576], array134[1048576], array135[1048576];
+vec4 array136[1048576], array137[1048576], array138[1048576], array139[1048576], array140[1048576];
+vec4 array141[1048576], array142[1048576], array143[1048576], array144[1048576], array145[1048576];
+vec4 array146[1048576], array147[1048576], array148[1048576], array149[1048576], array150[1048576];
+vec4 array151[1048576], array152[1048576], array153[1048576], array154[1048576], array155[1048576];
+vec4 array156[1048576], array157[1048576], array158[1048576], array159[1048576], array160[1048576];
+vec4 array161[1048576], array162[1048576], array163[1048576], array164[1048576], array165[1048576];
+vec4 array166[1048576], array167[1048576], array168[1048576], array169[1048576], array170[1048576];
+vec4 array171[1048576], array172[1048576], array173[1048576], array174[1048576], array175[1048576];
+vec4 array176[1048576], array177[1048576], array178[1048576], array179[1048576], array180[1048576];
+vec4 array181[1048576], array182[1048576], array183[1048576], array184[1048576], array185[1048576];
+vec4 array186[1048576], array187[1048576], array188[1048576], array189[1048576], array190[1048576];
+vec4 array191[1048576], array192[1048576], array193[1048576], array194[1048576], array195[1048576];
+vec4 array196[1048576], array197[1048576], array198[1048576], array199[1048576], array200[1048576];
+vec4 array201[1048576], array202[1048576], array203[1048576], array204[1048576], array205[1048576];
+vec4 array206[1048576], array207[1048576], array208[1048576], array209[1048576], array210[1048576];
+vec4 array211[1048576], array212[1048576], array213[1048576], array214[1048576], array215[1048576];
+vec4 array216[1048576], array217[1048576], array218[1048576], array219[1048576], array220[1048576];
+vec4 array221[1048576], array222[1048576], array223[1048576], array224[1048576], array225[1048576];
+vec4 array226[1048576], array227[1048576], array228[1048576], array229[1048576], array230[1048576];
+vec4 array231[1048576], array232[1048576], array233[1048576], array234[1048576], array235[1048576];
+vec4 array236[1048576], array237[1048576], array238[1048576], array239[1048576], array240[1048576];
+vec4 array241[1048576], array242[1048576], array243[1048576], array244[1048576], array245[1048576];
+vec4 array246[1048576], array247[1048576], array248[1048576], array249[1048576], array250[1048576];
+vec4 array251[1048576], array252[1048576], array253[1048576], array254[1048576], array255[1048576];
+vec4 array256[1048576];
+
+void main()
+{
+    float f = array[0].x; f += array2[0].x; f += array3[0].x; f += array4[0].x; f += array5[0].x;
+    f += array6[0].x; f += array7[0].x; f += array8[0].x; f += array9[0].x; f += array10[0].x;
+    f += array11[0].x; f += array12[0].x; f += array13[0].x; f += array14[0].x; f += array15[0].x;
+    f += array16[0].x; f += array17[0].x; f += array18[0].x; f += array19[0].x; f += array20[0].x;
+    f += array21[0].x; f += array22[0].x; f += array23[0].x; f += array24[0].x; f += array25[0].x;
+    f += array26[0].x; f += array27[0].x; f += array28[0].x; f += array29[0].x; f += array30[0].x;
+    f += array31[0].x; f += array32[0].x; f += array33[0].x; f += array34[0].x; f += array35[0].x;
+    f += array36[0].x; f += array37[0].x; f += array38[0].x; f += array39[0].x; f += array40[0].x;
+    f += array41[0].x; f += array42[0].x; f += array43[0].x; f += array44[0].x; f += array45[0].x;
+    f += array46[0].x; f += array47[0].x; f += array48[0].x; f += array49[0].x; f += array50[0].x;
+    f += array51[0].x; f += array52[0].x; f += array53[0].x; f += array54[0].x; f += array55[0].x;
+    f += array56[0].x; f += array57[0].x; f += array58[0].x; f += array59[0].x; f += array60[0].x;
+    f += array61[0].x; f += array62[0].x; f += array63[0].x; f += array64[0].x; f += array65[0].x;
+    f += array66[0].x; f += array67[0].x; f += array68[0].x; f += array69[0].x; f += array70[0].x;
+    f += array71[0].x; f += array72[0].x; f += array73[0].x; f += array74[0].x; f += array75[0].x;
+    f += array76[0].x; f += array77[0].x; f += array78[0].x; f += array79[0].x; f += array80[0].x;
+    f += array81[0].x; f += array82[0].x; f += array83[0].x; f += array84[0].x; f += array85[0].x;
+    f += array86[0].x; f += array87[0].x; f += array88[0].x; f += array89[0].x; f += array90[0].x;
+    f += array91[0].x; f += array92[0].x; f += array93[0].x; f += array94[0].x; f += array95[0].x;
+    f += array96[0].x; f += array97[0].x; f += array98[0].x; f += array99[0].x; f += array100[0].x;
+    f += array101[0].x; f += array102[0].x; f += array103[0].x; f += array104[0].x;
+    f += array105[0].x; f += array106[0].x; f += array107[0].x; f += array108[0].x;
+    f += array109[0].x; f += array110[0].x; f += array111[0].x; f += array112[0].x;
+    f += array113[0].x; f += array114[0].x; f += array115[0].x; f += array116[0].x;
+    f += array117[0].x; f += array118[0].x; f += array119[0].x; f += array120[0].x;
+    f += array121[0].x; f += array122[0].x; f += array123[0].x; f += array124[0].x;
+    f += array125[0].x; f += array126[0].x; f += array127[0].x; f += array128[0].x;
+    f += array129[0].x; f += array130[0].x; f += array131[0].x; f += array132[0].x;
+    f += array133[0].x; f += array134[0].x; f += array135[0].x; f += array136[0].x;
+    f += array137[0].x; f += array138[0].x; f += array139[0].x; f += array140[0].x;
+    f += array141[0].x; f += array142[0].x; f += array143[0].x; f += array144[0].x;
+    f += array145[0].x; f += array146[0].x; f += array147[0].x; f += array148[0].x;
+    f += array149[0].x; f += array150[0].x; f += array151[0].x; f += array152[0].x;
+    f += array153[0].x; f += array154[0].x; f += array155[0].x; f += array156[0].x;
+    f += array157[0].x; f += array158[0].x; f += array159[0].x; f += array160[0].x;
+    f += array161[0].x; f += array162[0].x; f += array163[0].x; f += array164[0].x;
+    f += array165[0].x; f += array166[0].x; f += array167[0].x; f += array168[0].x;
+    f += array169[0].x; f += array170[0].x; f += array171[0].x; f += array172[0].x;
+    f += array173[0].x; f += array174[0].x; f += array175[0].x; f += array176[0].x;
+    f += array177[0].x; f += array178[0].x; f += array179[0].x; f += array180[0].x;
+    f += array181[0].x; f += array182[0].x; f += array183[0].x; f += array184[0].x;
+    f += array185[0].x; f += array186[0].x; f += array187[0].x; f += array188[0].x;
+    f += array189[0].x; f += array190[0].x; f += array191[0].x; f += array192[0].x;
+    f += array193[0].x; f += array194[0].x; f += array195[0].x; f += array196[0].x;
+    f += array197[0].x; f += array198[0].x; f += array199[0].x; f += array200[0].x;
+    f += array201[0].x; f += array202[0].x; f += array203[0].x; f += array204[0].x;
+    f += array205[0].x; f += array206[0].x; f += array207[0].x; f += array208[0].x;
+    f += array209[0].x; f += array210[0].x; f += array211[0].x; f += array212[0].x;
+    f += array213[0].x; f += array214[0].x; f += array215[0].x; f += array216[0].x;
+    f += array217[0].x; f += array218[0].x; f += array219[0].x; f += array220[0].x;
+    f += array221[0].x; f += array222[0].x; f += array223[0].x; f += array224[0].x;
+    f += array225[0].x; f += array226[0].x; f += array227[0].x; f += array228[0].x;
+    f += array229[0].x; f += array230[0].x; f += array231[0].x; f += array232[0].x;
+    f += array233[0].x; f += array234[0].x; f += array235[0].x; f += array236[0].x;
+    f += array237[0].x; f += array238[0].x; f += array239[0].x; f += array240[0].x;
+    f += array241[0].x; f += array242[0].x; f += array243[0].x; f += array244[0].x;
+    f += array245[0].x; f += array246[0].x; f += array247[0].x; f += array248[0].x;
+    f += array249[0].x; f += array250[0].x; f += array251[0].x; f += array252[0].x;
+    f += array253[0].x; f += array254[0].x; f += array255[0].x; f += array256[0].x;
+    if (f == 2.0)
+        gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
+    else
+        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
+})";
+
     GLuint program = CompileProgram(essl1_shaders::vs::Simple(), kTooLargeGlobalMemory1);
     EXPECT_EQ(0u, program);
 
@@ -5449,6 +5574,9 @@ void main()
 
     program = CompileProgram(essl1_shaders::vs::Simple(), kTooLargeGlobalAndLocalMemory2);
     EXPECT_EQ(0u, program);
+
+    program = CompileProgram(essl1_shaders::vs::Simple(), kTooLargeGlobalMemoryOverflow);
+    EXPECT_EQ(0u, program);
 }
 
 // Linking should fail when corresponding vertex/fragment uniform blocks have different precision
